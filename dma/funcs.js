const expData = [
  {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
    {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    price: "$6.49",
    period: "weekly",
    pros: ["Amazing uptime, stability & power", "The best overall value", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    pricegray: false,
    type: "35T",
    categories: ["cheat", "firmware"],
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance.  \n- On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation:  \n  *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. \n\n- Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/), and [@spectraluwu](/).\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",
    href: "https://zenith.win",
    priceHref: "https://bloxproducts.com/?affiliate_key=1270744029168009258#Zenith",
    hide: false,
    warning: true,
    warningInfo: "",
  },
]

class PerformanceMonitor {
  constructor() {
    this.fps = 0
    this.frameCount = 0
    this.lastTime = performance.now()
    this.memoryUsage = 0
    this.deviceTier = "unknown"
    this.isLowEndDevice = false
  }

  start() {
    this.checkDevicePerformance()
    this.monitorFPS()
    return this
  }

  monitorFPS() {
    const updateFPS = () => {
      const now = performance.now()
      const elapsed = now - this.lastTime

      if (elapsed >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / elapsed)
        this.frameCount = 0
        this.lastTime = now

        if (typeof performance.memory !== "undefined") {
          this.memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024)
        }
      }

      this.frameCount++
      requestAnimationFrame(updateFPS)
    }

    requestAnimationFrame(updateFPS)
  }

  checkDevicePerformance() {
    const memoryScore = this.getMemoryScore()
    const cpuScore = this.getCPUScore()

    const totalScore = cpuScore * 0.7 + memoryScore * 0.3

    if (totalScore < 30) {
      this.deviceTier = "low"
      this.isLowEndDevice = true
    } else if (totalScore < 60) {
      this.deviceTier = "medium"
      this.isLowEndDevice = false
    } else {
      this.deviceTier = "high"
      this.isLowEndDevice = false
    }

    return this.deviceTier
  }

  getCPUScore() {
    const samples = 3
    let totalIterations = 0

    for (let sample = 0; sample < samples; sample++) {
      const startTime = performance.now()
      let iterations = 0

      while (performance.now() - startTime < 100) {
        for (let i = 0; i < 5000; i++) {
          Math.sqrt(Math.random() * 10000)
          Math.sin(Math.random() * Math.PI)
          Math.cos(Math.random() * Math.PI)
        }
        iterations++
      }

      totalIterations += iterations
    }

    const avgIterations = totalIterations / samples
    return Math.min(100, avgIterations * 4)
  }

  getMemoryScore() {
    let memoryScore = 50

    if (typeof navigator.deviceMemory !== "undefined") {
      memoryScore = Math.min(100, navigator.deviceMemory * 12.5)
    } else if (typeof performance.memory !== "undefined") {
      const totalJSHeapSize = performance.memory.jsHeapSizeLimit / (1024 * 1024)
      memoryScore = Math.min(100, totalJSHeapSize / 20)
    }

    return memoryScore
  }
}

class LazyLoader {
  constructor() {
    this.observer = null
    this.initialized = false
  }

  init() {
    if ("IntersectionObserver" in window) {
      this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
        rootMargin: "200px",
        threshold: 0.1,
      })
      this.initialized = true
    }
    return this
  }

  observe(elements) {
    if (!this.initialized) return

    if (elements instanceof NodeList || Array.isArray(elements)) {
      elements.forEach((el) => this.observer.observe(el))
    } else if (elements instanceof Element) {
      this.observer.observe(elements)
    }
  }

  onIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const element = entry.target

        if (element.dataset.lazySrc) {
          element.src = element.dataset.lazySrc
          delete element.dataset.lazySrc
        }

        if (element.dataset.lazyBg) {
          element.style.backgroundImage = `url(${element.dataset.lazyBg})`
          delete element.dataset.lazyBg
        }

        if (element.classList.contains("lazy-load")) {
          element.classList.add("loaded")
          element.classList.remove("lazy-load")
        }

        this.observer.unobserve(element)
      }
    })
  }
}

class PaginationManager {
  constructor(containerSelector, itemCreator, dataSource, options = {}) {
    this.container = document.querySelector(containerSelector)
    this.itemCreator = itemCreator
    this.dataSource = dataSource
    this.options = {
      itemsPerPage: options.itemsPerPage || 9,
      ...options,
    }

    this.currentPage = 1
    this.totalPages = 1
    this.renderedItems = new Map()
    this.initialized = false

    this.paginationContainer = document.getElementById("paginationContainer")
    this.prevBtn = document.getElementById("prevPageBtn")
    this.nextBtn = document.getElementById("nextPageBtn")
    this.pageNumbers = document.getElementById("pageNumbers")
    this.paginationInfo = document.getElementById("paginationInfo")
    this.pageInfo = document.getElementById("pageInfo")
  }

  init() {
    if (!this.container) return this

    this.setupPaginationControls()
    this.render()
    this.initialized = true

    return this
  }

  setupPaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.addEventListener("click", () => {
        if (this.currentPage > 1) {
          this.goToPage(this.currentPage - 1)
        }
      })
    }

    if (this.nextBtn) {
      this.nextBtn.addEventListener("click", () => {
        if (this.currentPage < this.totalPages) {
          this.goToPage(this.currentPage + 1)
        }
      })
    }
  }

  updateData(newData) {
    this.dataSource = newData
    this.currentPage = 1
    this.clear()
    this.render()
  }

  calculateTotalPages() {
    return Math.ceil(this.dataSource.length / this.options.itemsPerPage)
  }

  getCurrentPageData() {
    const startIndex = (this.currentPage - 1) * this.options.itemsPerPage
    const endIndex = startIndex + this.options.itemsPerPage
    return this.dataSource.slice(startIndex, endIndex)
  }

  goToPage(pageNumber) {
    if (pageNumber < 1 || pageNumber > this.totalPages) return

    this.currentPage = pageNumber
    this.clear()
    this.render()
  }

  render() {
    this.totalPages = this.calculateTotalPages()

    if (this.totalPages === 0) {
      this.hidePagination()
      return
    }

    this.showPagination()

    const currentPageData = this.getCurrentPageData()
    const fragment = document.createDocumentFragment()

    this.container.innerHTML = ""

    currentPageData.forEach((data, index) => {
      const element = this.itemCreator(data, index)
      if (element) {
        fragment.appendChild(element)
      }
    })

    this.container.appendChild(fragment)
    this.updatePaginationControls()
    this.updatePageInfo()
  }

  updatePaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.disabled = this.currentPage === 1
    }

    if (this.nextBtn) {
      this.nextBtn.disabled = this.currentPage === this.totalPages
    }

    if (this.pageNumbers) {
      this.pageNumbers.innerHTML = ""

      const maxVisiblePages = 5
      let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2))
      const endPage = Math.min(this.totalPages, startPage + maxVisiblePages - 1)

      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1)
      }

      if (startPage > 1) {
        this.addPageButton(1)
        if (startPage > 2) {
          this.addEllipsis()
        }
      }

      for (let i = startPage; i <= endPage; i++) {
        this.addPageButton(i)
      }

      if (endPage < this.totalPages) {
        if (endPage < this.totalPages - 1) {
          this.addEllipsis()
        }
        this.addPageButton(this.totalPages)
      }
    }

    if (this.paginationInfo) {
      this.paginationInfo.textContent = `Page ${this.currentPage} of ${this.totalPages}`
    }
  }

  addPageButton(pageNumber) {
    const button = document.createElement("button")
    button.className = `page-number ${pageNumber === this.currentPage ? "active" : ""}`
    button.textContent = pageNumber
    button.addEventListener("click", () => this.goToPage(pageNumber))
    this.pageNumbers.appendChild(button)
  }

  addEllipsis() {
    const ellipsis = document.createElement("span")
    ellipsis.className = "page-ellipsis"
    ellipsis.textContent = "..."
    this.pageNumbers.appendChild(ellipsis)
  }

  updatePageInfo() {
    if (this.pageInfo) {
      const startItem = (this.currentPage - 1) * this.options.itemsPerPage + 1
      const endItem = Math.min(this.currentPage * this.options.itemsPerPage, this.dataSource.length)
      this.pageInfo.textContent = ` (${startItem}-${endItem})`
    }
  }

  showPagination() {
    if (this.paginationContainer && this.totalPages > 1) {
      this.paginationContainer.style.display = "block"
    }
  }

  hidePagination() {
    if (this.paginationContainer) {
      this.paginationContainer.style.display = "none"
    }
  }

  clear() {
    this.renderedItems.clear()
    if (this.container) {
      this.container.innerHTML = ""
    }
  }
}

class AppState {
  constructor() {
    this.view = "grid"
    this.query = ""
    this.firmwareFilter = "all"
    this.cheatOnly = false
    this.firmwareOnly = false
    this.dmaOnly = false
    this.mouseControlOnly = false
    this.sortBy = "recommended"
    this.filteredData = []
    this.performanceMonitor = new PerformanceMonitor().start()
    this.lazyLoader = new LazyLoader().init()
    this.paginationManager = null
    this.isLoading = false
    this.scrollPosition = 0
    this.isFilterDrawerOpen = false
  }

  init() {
    this.filteredData = expData.filter((exp) => exp.hide !== true)
    return this
  }

  filterExploits() {
    this.filteredData = expData
      .filter((exp) => {
        if (exp.hide === true) return false

        if (this.query) {
          const query = this.query.toLowerCase()
          const nameMatch = exp.name.toLowerCase().includes(query)
          const descMatch = exp.desc.toLowerCase().includes(query)

          if (!(nameMatch || descMatch)) {
            return false
          }
        }

        if (this.firmwareFilter !== "all") {
          if (exp.type !== this.firmwareFilter) {
            return false
          }
        }

        if (this.cheatOnly) {
          const hasCheatInName = exp.name.toLowerCase().includes("cheat")
          const hasCheatInCategories = exp.categories && exp.categories.includes("cheat")
          if (!hasCheatInName && !hasCheatInCategories) {
            return false
          }
        }

        if (this.firmwareOnly) {
          const hasFirmwareInName = exp.name.toLowerCase().includes("firmware")
          const hasFirmwareInCategories = exp.categories && exp.categories.includes("firmware")
          if (!hasFirmwareInName && !hasFirmwareInCategories) {
            return false
          }
        }

        if (this.dmaOnly) {
          const hasDmaInName = exp.name.toLowerCase().includes("dma")
          const hasDmaInCategories = exp.categories && exp.categories.includes("dma")
          if (!hasDmaInName && !hasDmaInCategories) {
            return false
          }
        }

        if (this.mouseControlOnly) {
          const hasMouseInName = exp.name.toLowerCase().includes("mouse")
          const hasControlInName = exp.name.toLowerCase().includes("control")
          const hasMouseControlInCategories = exp.categories && exp.categories.includes("mousecontrol")
          if (!hasMouseInName && !hasControlInName && !hasMouseControlInCategories) {
            return false
          }
        }

        return true
      })
      .sort((a, b) => {
        switch (this.sortBy) {
          case "price-asc":
            return this.comparePrices(a, b)
          case "price-desc":
            return this.comparePrices(b, a)
          case "name-asc":
            return a.name.localeCompare(b.name)
          default:
            if (a.verified && !b.verified) return -1
            if (!a.verified && b.verified) return 1
            if (a.premium && !b.premium) return -1
            if (!a.premium && b.premium) return 1
            return 0
        }
      })

    return this.filteredData
  }

  comparePrices(a, b) {
    const getPriceValue = (price) => {
      if (Array.isArray(price)) {
        return Number.parseFloat(price[0].replace(/[^\d.]/g, "")) || 0
      }
      return price === "FREE" ? 0 : Number.parseFloat(price.replace(/[^\d.]/g, "")) || 0
    }

    return getPriceValue(a.price) - getPriceValue(b.price)
  }

  saveScrollPosition() {
    this.scrollPosition = window.pageYOffset || document.documentElement.scrollTop
  }

  restoreScrollPosition() {
    if (this.scrollPosition > 0) {
      window.scrollTo(0, this.scrollPosition)
    }
  }
}

class UIManager {
  constructor(appState) {
    this.appState = appState
    this.elements = {}
    this.debounceTimers = {}
    this.isUpdating = false
  }

  init() {
    this.initElements()
    this.setupEventListeners()
    this.updateCounts()
    this.initPaginationManager()
    this.createModals()
    this.setupDropdowns()
    this.initTextSwitching()
    this.updateScrollbarStyles()
    this.handleWindowResize()

    return this
  }

  initElements() {
    const selectors = {
      header: "#hdr",
      hero: "#heroSec",
      menuToggle: "#mobMenuTgl",
      menu: "#mobMenu",
      search: "#srchInp",
      mobileSearch: "#mobSrchInp",
      clearButton: "#clrSrch",
      mobileClearButton: "#mobClrSrch",
      filterButton: "#fltrBtn",
      mobileFilterButton: "#mobFltrBtn",
      drawer: "#fltrDrwr",
      applyButton: "#applyFltrs",
      closeButton: "#fasfa-times",
      cheatSwitch: "#vrfSwch",
      mobileCheatSwitch: "#mobVrfSwch",
      firmwareSwitch: "#premSwch",
      mobileFirmwareSwitch: "#mobPremSwch",
      dmaSwitch: "#extSwch",
      mobileDmaSwitch: "#mobExtSwch",
      mouseControlSwitch: "#execSwch",
      mobileMouseControlSwitch: "#mobExecSwch",
      sortSelect: "#srtSel",
      mobileSortSelect: "#mobSortSel",
      resetButton: "#rstFltrs",
      mobileResetButton: "#mobRstFltrs",
      resetAllButton: "#rstAllFltrs",
      grid: "#expsGrid",
      list: "#expsList",
      noResults: "#noRes",
      filteredCount: "#fltrdCnt",
      totalCount: "#ttlCnt",
      tabButtons: ".tab-trgr",
      tabContent: ".tab-cntnt",
      canvas: "#strCnv",
      loadingScreen: "#loadingScreen",
      loadingBar: "#loadingBar",
      logoTextGradient: ".logo-txt-grd",
      logoTextLight: ".logo-txt-lt",
      themeDropdown: "#themeDropdown",
      themeDropdownSelected: "#themeDropdownSelected",
      themeDropdownOptions: "#themeDropdownOptions",
    }

    for (const [key, selector] of Object.entries(selectors)) {
      if (selector.startsWith(".")) {
        this.elements[key] = document.querySelectorAll(selector)
      } else {
        this.elements[key] = document.getElementById(selector.substring(1))
      }
    }
  }

  getElement(key) {
    return this.elements[key]
  }

  debounce(func, wait, key) {
    return (...args) => {
      clearTimeout(this.debounceTimers[key])
      this.debounceTimers[key] = setTimeout(() => func.apply(this, args), wait)
    }
  }

  setupEventListeners() {
    window.addEventListener(
      "scroll",
      this.debounce(
        () => {
          const heroHeight = this.getElement("hero") ? this.getElement("hero").offsetHeight : 0
          if (window.scrollY > heroHeight / 2) {
            this.getElement("header").classList.add("scrolled")
          } else {
            this.getElement("header").classList.remove("scrolled")
          }
        },
        50,
        "scroll",
      ),
    )

    const menuToggle = this.getElement("menuToggle")
    const menu = this.getElement("menu")
    if (menuToggle && menu) {
      menuToggle.addEventListener("click", () => {
        menu.classList.toggle("hidden")
        document.body.classList.toggle("menu-open")
        menuToggle.innerHTML = menu.classList.contains("hidden")
          ? '<i class="fas fa-bars"></i>'
          : '<i class="fas fa-times"></i>'
      })
    }

    this.setupSearchListeners()
    this.setupFilterDrawer()
    this.setupFirmwareFilters()
    this.setupToggleSwitches()
    this.setupSortSelects()
    this.setupResetButtons()
    this.setupTabButtons()

    window.addEventListener("resize", this.debounce(this.handleWindowResize.bind(this), 100, "resize"))
  }

  setupSearchListeners() {
    const search = this.getElement("search")
    const mobileSearch = this.getElement("mobileSearch")
    const clearButton = this.getElement("clearButton")
    const mobileClearButton = this.getElement("mobileClearButton")

    const handleSearchInput = this.debounce(
      (e) => {
        this.appState.query = e.target.value
        if (mobileSearch && e.target !== mobileSearch) mobileSearch.value = this.appState.query
        if (search && e.target !== search) search.value = this.appState.query
        if (clearButton) clearButton.classList.toggle("hidden", !this.appState.query)
        if (mobileClearButton) mobileClearButton.classList.toggle("hidden", !this.appState.query)
        this.updateExploits()
      },
      200,
      "search",
    )

    if (search) {
      search.addEventListener("input", handleSearchInput)
    }

    if (mobileSearch) {
      mobileSearch.addEventListener("input", handleSearchInput)
    }

    const clearSearch = () => {
      this.appState.query = ""
      if (search) search.value = ""
      if (mobileSearch) mobileSearch.value = ""
      if (clearButton) clearButton.classList.add("hidden")
      if (mobileClearButton) mobileClearButton.classList.add("hidden")
      this.updateExploits()
    }

    if (clearButton) {
      clearButton.addEventListener("click", clearSearch)
    }

    if (mobileClearButton) {
      mobileClearButton.addEventListener("click", clearSearch)
    }
  }

  setupFilterDrawer() {
    const filterButton = this.getElement("filterButton")
    const mobileFilterButton = this.getElement("mobileFilterButton")
    const drawer = this.getElement("drawer")
    const applyButton = this.getElement("applyButton")
    const closeButton = this.getElement("closeButton")

    const openDrawer = () => {
      this.appState.saveScrollPosition()
      this.appState.isFilterDrawerOpen = true
      drawer.classList.add("open")
      document.body.style.overflow = "hidden"
      document.body.style.position = "fixed"
      document.body.style.top = `-${this.appState.scrollPosition}px`
      document.body.style.width = "100%"
    }

    const closeDrawer = () => {
      this.appState.isFilterDrawerOpen = false
      drawer.classList.remove("open")
      document.body.style.overflow = ""
      document.body.style.position = ""
      document.body.style.top = ""
      document.body.style.width = ""

      setTimeout(() => {
        this.appState.restoreScrollPosition()
      }, 10)
    }

    if (filterButton && drawer) {
      filterButton.addEventListener("click", openDrawer)
    }

    if (mobileFilterButton && drawer) {
      mobileFilterButton.addEventListener("click", () => {
        openDrawer()
        const menu = this.getElement("menu")
        const menuToggle = this.getElement("menuToggle")
        if (menu) menu.classList.add("hidden")
        if (menuToggle) menuToggle.innerHTML = '<i class="fas fa-bars"></i>'
        document.body.classList.remove("menu-open")
      })
    }

    if (drawer) {
      const overlay = drawer.querySelector(".fltr-drwr-ovl")
      if (overlay) {
        overlay.addEventListener("click", closeDrawer)
      }
    }

    if (applyButton && drawer) {
      applyButton.addEventListener("click", closeDrawer)
    }

    if (closeButton && drawer) {
      closeButton.addEventListener("click", closeDrawer)
    }
  }

  setupFirmwareFilters() {
    document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((button) => {
      button.addEventListener("click", () => {
        const firmware = button.getAttribute("data-prc")
        this.appState.firmwareFilter = firmware

        document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
          btn.classList.remove("actv")
          if (btn.getAttribute("data-prc") === firmware) {
            btn.classList.add("actv")
          }
        })

        this.updateExploits()
      })
    })
  }

  setupToggleSwitches() {
    const setupSwitchPair = (mainSwitch, mobileSwitch, stateProperty) => {
      if (mainSwitch) {
        mainSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mainSwitch.checked
          if (mobileSwitch) mobileSwitch.checked = mainSwitch.checked
          this.updateExploits()
        })
      }

      if (mobileSwitch) {
        mobileSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mobileSwitch.checked
          if (mainSwitch) mainSwitch.checked = mobileSwitch.checked
          this.updateExploits()
        })
      }
    }

    setupSwitchPair(this.getElement("cheatSwitch"), this.getElement("mobileCheatSwitch"), "cheatOnly")
    setupSwitchPair(this.getElement("firmwareSwitch"), this.getElement("mobileFirmwareSwitch"), "firmwareOnly")
    setupSwitchPair(this.getElement("dmaSwitch"), this.getElement("mobileDmaSwitch"), "dmaOnly")
    setupSwitchPair(
      this.getElement("mouseControlSwitch"),
      this.getElement("mobileMouseControlSwitch"),
      "mouseControlOnly",
    )
  }

  setupSortSelects() {
    const sortSelect = this.getElement("sortSelect")
    const mobileSortSelect = this.getElement("mobileSortSelect")

    if (sortSelect) {
      sortSelect.addEventListener("change", () => {
        this.appState.sortBy = sortSelect.value
        if (mobileSortSelect) mobileSortSelect.value = this.appState.sortBy
        this.updateExploits()
      })
    }

    if (mobileSortSelect) {
      mobileSortSelect.addEventListener("change", () => {
        this.appState.sortBy = mobileSortSelect.value
        if (sortSelect) sortSelect.value = this.appState.sortBy
        this.updateExploits()
      })
    }
  }

  setupResetButtons() {
    const resetFilters = () => {
      this.appState.firmwareFilter = "all"
      this.appState.cheatOnly = false
      this.appState.firmwareOnly = false
      this.appState.dmaOnly = false
      this.appState.mouseControlOnly = false

      document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
        btn.classList.remove("actv")
        if (btn.getAttribute("data-prc") === "all") {
          btn.classList.add("actv")
        }
      })

      const switches = [
        "cheatSwitch",
        "mobileCheatSwitch",
        "firmwareSwitch",
        "mobileFirmwareSwitch",
        "dmaSwitch",
        "mobileDmaSwitch",
        "mouseControlSwitch",
        "mobileMouseControlSwitch",
      ]

      switches.forEach((switchKey) => {
        const switchElement = this.getElement(switchKey)
        if (switchElement) switchElement.checked = false
      })

      this.updateExploits()
    }

    const resetButtons = [
      this.getElement("resetButton"),
      this.getElement("mobileResetButton"),
      this.getElement("resetAllButton"),
    ]

    resetButtons.forEach((button) => {
      if (button) {
        button.addEventListener("click", resetFilters)
      }
    })
  }

  setupTabButtons() {
    const tabButtons = this.getElement("tabButtons")
    const tabContent = this.getElement("tabContent")

    if (tabButtons && tabButtons.length) {
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.getAttribute("data-tab")
          this.appState.view = tab

          tabButtons.forEach((btn) => btn.classList.remove("actv"))
          button.classList.add("actv")

          if (tabContent && tabContent.length) {
            tabContent.forEach((content) => content.classList.remove("actv"))
            const activeContent = document.getElementById(`${tab}Tab`)
            if (activeContent) activeContent.classList.add("actv")
          }

          this.updateExploits()
        })
      })
    }
  }

  initPaginationManager() {
    const grid = this.getElement("grid")

    if (grid) {
      this.appState.paginationManager = new PaginationManager(
        "#expsGrid",
        this.createCard.bind(this),
        this.appState.filteredData,
        {
          itemsPerPage: 9,
        },
      ).init()
    }
  }

  updateExploits() {
    if (this.isUpdating) return
    this.isUpdating = true

    requestAnimationFrame(() => {
      try {
        const filteredData = this.appState.filterExploits()
        const noResults = this.getElement("noResults")

        if (filteredData.length === 0) {
          if (noResults) noResults.classList.remove("hidden")
        } else {
          if (noResults) noResults.classList.add("hidden")
        }

        if (this.appState.paginationManager && this.appState.view === "grid") {
          this.appState.paginationManager.updateData(filteredData)
        }

        this.updateCounts()

        setTimeout(() => {
          this.setupCardButtons()
          this.isUpdating = false
        }, 50)
      } catch (error) {
        console.error("Error updating exploits:", error)
        this.isUpdating = false
      }
    })
  }

  createCard(exploit) {
    const card = document.createElement("div")
    card.className = "exp-crd"
    if (exploit.premium) card.classList.add("prem")

    card.setAttribute("data-id", exploit.id)
    card.setAttribute("data-name", exploit.name)

    const accentColor = exploit.premium ? "prem" : exploit.accentColor

    card.innerHTML = `
  <div class="crd-acnt ${accentColor}"></div>
  <div class="crd-hdr">
    <div class="crd-hdr-cntnt">
      <div class="crd-ttl-cntr">
        <h3 class="crd-ttl">
          ${exploit.name}
          ${exploit.verified ? `<span class="vrf-bdg"><i class="fas fa-check"></i>Verified</span>` : ""}
          ${exploit.premium ? `<span class="prem-bdg"><i class="fas fa-crown"></i>Premium</span>` : ""}
          ${exploit.warning ? `<span class="warn-bdg"><i class="fas fa-exclamation-triangle"></i>Warning</span>` : ""}
        </h3>
        <p class="crd-desc">${exploit.desc}</p>
      </div>
      <!-- Category badges removed -->
    </div>
  </div>
  <div class="crd-bdy">
    <div class="crd-meta">
      <div class="lvl-bdg ${exploit.txtColor}">${exploit.type}</div>
      <div class="meta-sep"></div>
      <div class="edr-info">Last edited by ${exploit.editor}</div>
    </div>
    <div class="crd-cntnt cstm-scrlbr">
      ${this.renderFeatureSection(exploit.pros, "pros", "+")}
      ${this.renderFeatureSection(exploit.neutral, "ntrl", "•")}
      ${this.renderFeatureSection(exploit.cons, "cons", "-")}
    </div>
  </div>
  <div class="crd-ftr">
    ${this.renderCardFooter(exploit)}
  </div>
`

    return card
  }

  renderFeatureSection(features, className, icon) {
    if (!features || features.length === 0) return ""

    return `
  <div class="feat-sec ${className}">
    <h4 class="feat-hdng">
      <span class="feat-ico">${icon}</span>
      ${className === "pros" ? "Pros" : className === "ntrl" ? "Neutral" : "Cons"}
    </h4>
    <ul class="feat-lst">
      ${features.map((feature) => `<li class="feat-itm">${feature}</li>`).join("")}
    </ul>
  </div>
`
  }

  renderCardFooter(exploit) {
    if (exploit.price === "FREE") {
      return `
        <div class="btn-grid free-program-grid">
          <button class="crd-btn info-btn full-width">
            <div class="text-container">
              <span class="text-switch visible" data-text="info">INFO</span>
              <span class="text-switch hidden" data-text="more">MORE</span>
            </div>
            <i class="fas fa-info-circle"></i>
          </button>
        </div>
        <button class="crd-btn web-btn full-width">
          ${exploit.websitetofree ? "Free" : "Website"} <i class="fas fa-external-link-alt"></i>
        </button>
      `
    } else {
      const baseClasses = ["crd-btn", "prc-btn-new"]
      const finalPriceButtonClasses = baseClasses.join(" ")

      return `
        <div class="btn-grid">
          <button class="crd-btn web-btn expanded">
            ${exploit.websitetofree ? "Free" : "Website"} <i class="fas fa-external-link-alt"></i>
          </button>
          <button class="crd-btn info-btn expanded">
            <div class="text-container">
              <span class="text-switch visible" data-text="info">INFO</span>
              <span class="text-switch hidden" data-text="more">MORE</span>
            </div>
            <i class="fas fa-info-circle"></i>
          </button>
        </div>
        <button class="${finalPriceButtonClasses}">
          <div class="default-text">
            <i class="fas fa-tag"></i> BUY
          </div>
          <div class="price-text">
            <i class="fas fa-tag"></i> ${exploit.price} ${exploit.period ? `<span class="prc-prd">${exploit.period}</span>` : ""}
          </div>
        </button>
      `
    }
  }

  syncPriceButtonColors() {
    document.querySelectorAll(".exp-crd, .exp-lst-itm").forEach((cardElement) => {
      const exploit = this.findExploitByCardElement(cardElement)
      const priceButton = cardElement.querySelector(".prc-btn-new")

      if (priceButton && exploit) {
        if (exploit.pricegray === true) {
          const webButton = cardElement.querySelector(".web-btn")
          if (webButton) {
            const webButtonComputedStyle = window.getComputedStyle(webButton)
            const webButtonBgColor = webButtonComputedStyle.backgroundColor
            const webButtonTextColor = webButtonComputedStyle.color
            const webButtonBorderColor = webButtonComputedStyle.borderColor

            priceButton.style.backgroundColor = webButtonBgColor
            priceButton.style.color = webButtonTextColor
            priceButton.style.borderColor = webButtonBorderColor

            priceButton.querySelectorAll(".default-text, .price-text").forEach((child) => {
              child.style.color = webButtonTextColor
              const iconInChild = child.querySelector(".fas.fa-tag")
              if (iconInChild) {
                iconInChild.style.color = "white"
              }
            })
            const prcPrdElement = priceButton.querySelector(".prc-prd")
            if (prcPrdElement) {
              prcPrdElement.style.color = webButtonTextColor
            }
          }
        } else {
          priceButton.style.backgroundColor = ""
          priceButton.style.color = ""
          priceButton.style.borderColor = ""
          priceButton.querySelectorAll(".default-text, .price-text, .prc-prd").forEach((child) => {
            child.style.color = ""
            const iconInChild = child.querySelector(".fas.fa-tag")
            if (iconInChild) {
              iconInChild.style.color = ""
            }
          })
        }
      }
    })
  }

  setupCardButtons() {
    const setupButtonHandlers = () => {
      document.querySelectorAll(".info-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              ModalManager.openInfoModal(exploit)
            }
          }
        }
      })

      document.querySelectorAll(".web-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              if (exploit.warning === true) {
                ModalManager.showWarningModal(exploit)
              } else if (exploit.href) {
                window.open(exploit.href, "_blank")
              }
            }
          }
        }
      })

      document.querySelectorAll(".prc-btn-new").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit && exploit.priceHref) {
              window.open(exploit.priceHref, "_blank")
            }
          }
        }
      })
      this.syncPriceButtonColors()
    }

    setupButtonHandlers()

    const observer = new MutationObserver((mutations) => {
      let shouldReSync = false
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const node = mutation.addedNodes[i]
            if (
              node.nodeType === 1 &&
              (node.classList.contains("exp-crd") ||
                node.classList.contains("exp-lst-itm") ||
                node.querySelector(".exp-crd") ||
                node.querySelector(".exp-lst-itm"))
            ) {
              shouldReSync = true
              break
            }
          }
        }
      })

      if (shouldReSync) {
        setupButtonHandlers()
      }
    })

    observer.observe(document.body, { childList: true, subtree: true })

    this.syncPriceButtonColors()

    document.head.insertAdjacentHTML(
      "beforeend",
      `
      <style>
        .crd-btn.expanded {
          flex: 1;
          min-width: 0;
        }
        .crd-btn.full-width {
          width: 100%;
        }
        .ctgr-bdgs {
          display: flex;
          gap: 4px;
          flex-wrap: wrap;
        }
        .ctgr-bdg {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 24px;
          height: 24px;
          border-radius: 4px;
          background: rgba(255, 255, 255, 0.1);
          color: rgba(255, 255, 255, 0.8);
          font-size: 10px;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }
      </style>
    `,
    )
  }

  findExploitByCardElement(element) {
    if (!element) return null

    const dataName = element.getAttribute("data-name")
    if (dataName) {
      return expData.find((exp) => exp.name === dataName)
    }

    const nameElement = element.querySelector(".crd-ttl") || element.querySelector(".lst-itm-ttl")
    if (nameElement) {
      const fullText = nameElement.textContent.trim()
      const cleanName = fullText.replace(/Verified|Premium|Warning/g, "").trim()

      let exploit = expData.find((exp) => exp.name === cleanName)

      if (!exploit) {
        exploit = expData.find((exp) => cleanName.startsWith(exp.name))
      }

      return exploit
    }

    return null
  }

  updateCounts() {
    const filteredCount = this.getElement("filteredCount")
    const totalCount = this.getElement("totalCount")

    if (filteredCount) {
      this.animateCounter(
        filteredCount,
        Number.parseInt(filteredCount.textContent) || 0,
        this.appState.filteredData.length,
      )
    }

    if (totalCount) {
      this.animateCounter(totalCount, Number.parseInt(totalCount.textContent) || 0, expData.length)
    }
  }

  animateCounter(element, start, end) {
    if (!element || start === end) return

    if (element._countAnimation) {
      cancelAnimationFrame(element._countAnimation)
    }

    const duration = 800
    const startTime = performance.now()

    const updateCount = (timestamp) => {
      const elapsed = timestamp - startTime
      const progress = Math.min(elapsed / duration, 1)

      const easeOutQuart = (x) => 1 - Math.pow(1 - x, 4)
      const easedProgress = easeOutQuart(progress)

      const currentCount = Math.floor(start + (end - start) * easedProgress)

      element.textContent = currentCount

      if (progress < 1) {
        element._countAnimation = requestAnimationFrame(updateCount)
      } else {
        element.textContent = end
        element._countAnimation = null
      }
    }

    element._countAnimation = requestAnimationFrame(updateCount)
  }

  initTextSwitching() {
    const containers = document.querySelectorAll(
      ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container",
    )

    containers.forEach((container) => {
      const texts = container.querySelectorAll(".text-switch")

      container.style.position = "relative"
      container.style.display = "inline-flex"
      container.style.alignItems = "center"
      container.style.justifyContent = "center"
      container.style.minHeight = "20px"
      container.style.minWidth = "40px"

      texts.forEach((text) => {
        text.style.position = "absolute"
        text.style.top = "0"
        text.style.left = "0"
        text.style.width = "100%"
        text.style.height = "100%"
        text.style.display = "flex"
        text.style.alignItems = "center"
        text.style.justifyContent = "center"
        text.style.transition = "opacity 0.5s ease-in-out"
        text.style.opacity = text.classList.contains("visible") ? "1" : "0"
        text.style.pointerEvents = "none"
      })
    })

    const animationInterval = setInterval(() => {
      const currentContainers = document.querySelectorAll(
        ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container",
      )

      currentContainers.forEach((container) => {
        const visibleText = container.querySelector(".text-switch.visible")
        const hiddenText = container.querySelector(".text-switch.hidden")

        if (visibleText && hiddenText) {
          visibleText.style.opacity = "0"

          setTimeout(() => {
            visibleText.classList.remove("visible")
            visibleText.classList.add("hidden")
            hiddenText.classList.remove("hidden")
            hiddenText.classList.add("visible")
            hiddenText.offsetWidth
            setTimeout(() => {
              hiddenText.style.opacity = "1"
            }, 50)
          }, 250)
        }
      })
    }, 3000)

    this.textSwitchingInterval = animationInterval
  }

  updateScrollbarStyles() {
    const scrollableElements = [".crd-cntnt", ".info-modal-content", ".info-modal-markdown", ".fltr-drwr-bdy"]

    scrollableElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector)
      elements.forEach((el) => {
        el.style.overflow = "hidden"
        void el.offsetHeight
        el.style.overflow = ""
      })
    })
  }

  handleWindowResize() {
    const grid = this.getElement("grid")
    const menu = this.getElement("menu")
    const menuToggle = this.getElement("menuToggle")
    const windowWidth = window.innerWidth

    if (grid) {
      if (windowWidth < 640) {
        grid.style.gridTemplateColumns = "1fr"
      } else if (windowWidth < 1024) {
        grid.style.gridTemplateColumns = "repeat(auto-fill, minmax(280px, 1fr))"
      } else {
        grid.style.gridTemplateColumns = "repeat(auto-fill, minmax(300px, 1fr))"
      }
    }

    if (windowWidth > 768 && menu && !menu.classList.contains("hidden")) {
      menu.classList.add("hidden")
      document.body.classList.remove("menu-open")
      if (menuToggle) menuToggle.innerHTML = '<i class="fas fa-bars"></i>'
    }

    this.adjustSearchBar()

    if (this.appState.paginationManager) {
      this.appState.paginationManager.render()
    }
  }

  adjustSearchBar() {
    const searchContainer = document.querySelector(".hdr-ctr")
    const headerContainer = document.querySelector(".hdr-cntr")
    const filterButton = this.getElement("filterButton")
    const logoSection = document.querySelector(".hdr-lft")
    const searchInput = document.querySelector(".srch-inp")
    const searchIcon = document.querySelector(".srch-ico")

    if (!searchContainer || !headerContainer || !filterButton || !logoSection || !searchInput || !searchIcon) return

    const windowWidth = window.innerWidth

    if (windowWidth <= 768) {
      searchContainer.style.display = "none"
      return
    }

    searchContainer.style.display = "block"
    searchContainer.style.position = "absolute"
    searchContainer.style.left = "50%"
    searchContainer.style.transform = "translateX(-50%)"
    searchContainer.style.maxWidth = "400px"
    searchContainer.style.width = "auto"
    searchContainer.style.zIndex = "5"
  }

  createModals() {
    ModalManager.createInfoModal()
    ModalManager.createWarningModal()
  }

  setupDropdowns() {
    const pageOverlay = document.getElementById("pageOverlay") || document.createElement("div")

    if (!document.getElementById("pageOverlay")) {
      pageOverlay.id = "pageOverlay"
      pageOverlay.className = "page-overlay"
      document.body.appendChild(pageOverlay)
    }

    const dropdowns = document.querySelectorAll(".custom-dropdown")

    dropdowns.forEach((dropdown) => {
      const selected = dropdown.querySelector(".custom-dropdown-selected")
      const options = dropdown.querySelector(".custom-dropdown-options")
      const optionItems = dropdown.querySelectorAll(".custom-dropdown-option")

      if (selected) {
        selected.addEventListener("click", (e) => {
          e.stopPropagation()

          dropdowns.forEach((d) => {
            if (d !== dropdown && d.classList.contains("active")) {
              d.classList.remove("active")
            }
          })

          dropdown.classList.toggle("active")

          if (dropdown.classList.contains("active")) {
            pageOverlay.classList.add("active")
          } else {
            pageOverlay.classList.remove("active")
          }
        })
      }

      if (optionItems) {
        optionItems.forEach((option) => {
          option.addEventListener("click", () => {
            const value = option.getAttribute("data-value")
            const text = option.textContent

            if (selected && selected.querySelector("span")) {
              selected.querySelector("span").textContent = text
            }

            optionItems.forEach((opt) => opt.classList.remove("selected"))
            option.classList.add("selected")

            dropdown.classList.remove("active")
            pageOverlay.classList.remove("active")

            if (dropdown.closest(".srt-fltr-cntr") || dropdown.closest(".mob-srt-fltr-cntr")) {
              this.appState.sortBy = value
              this.updateExploits()
            }
          })
        })
      }
    })

    pageOverlay.addEventListener("click", () => {
      dropdowns.forEach((dropdown) => {
        dropdown.classList.remove("active")
      })

      pageOverlay.classList.remove("active")
    })
  }
}

class ModalManager {
  static createInfoModal() {
    const modalContainer = document.getElementById("infoModalContainer")

    if (modalContainer) {
      document.getElementById("infoModalOverlay").addEventListener("click", ModalManager.closeInfoModal)
      document.getElementById("infoModalCloseBtn").addEventListener("click", ModalManager.closeInfoModal)

      const footerCloseBtn = document.getElementById("infoModalFooterCloseBtn")

      if (footerCloseBtn) {
        footerCloseBtn.addEventListener("click", ModalManager.closeInfoModal)
      }
    }
  }

  static createWarningModal() {
    const modalContainer = document.createElement("div")
    modalContainer.id = "warningModal"
    modalContainer.className = "warning-modal-container"
    modalContainer.style.display = "none"

    modalContainer.innerHTML = `
  <div class="warning-modal-overlay"></div>
  <div class="warning-modal">
    <div class="warning-modal-header">
      <h2 class="warning-modal-title">Warning</h2>
    </div>
    <div class="warning-modal-content">
      <div class="warning-modal-icon">
        <i class="fas fa-exclamation-triangle"></i>
      </div>
      <p id="warningModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
    </div>
    <div class="warning-modal-footer">
      <button id="warningModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
      <button id="warningModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
    </div>
  </div>
`

    document.body.appendChild(modalContainer)
  }

  static openInfoModal(exploit) {
    const modalContainer = document.getElementById("infoModalContainer")
    const modalTitle = document.getElementById("infoModalTitle")
    const modalExploitName = document.getElementById("infoModalExploitName")
    const modalExploitDesc = document.getElementById("infoModalExploitDesc")
    const modalMarkdown = document.getElementById("infoModalMarkdown")

    modalContainer.style.display = "flex"
    modalTitle.textContent = `${exploit.name} Information`
    modalExploitName.textContent = exploit.name
    modalExploitDesc.textContent = exploit.desc

    if (exploit.info) {
      const marked = window.marked
      modalMarkdown.innerHTML = marked.parse(exploit.info)

      if (window.hljs) {
        document.querySelectorAll("#infoModalMarkdown pre code").forEach((block) => {
          window.hljs.highlightElement(block)
        })
      }
    } else {
      modalMarkdown.innerHTML = "<p>No additional information available for this exploit.</p>"
    }

    setTimeout(() => {
      document.querySelector(".info-modal").classList.add("show")
    }, 10)

    document.body.style.overflow = "hidden"
  }

  static closeInfoModal() {
    const modal = document.querySelector(".info-modal")

    if (modal) {
      modal.classList.remove("show")

      setTimeout(() => {
        const container = document.getElementById("infoModalContainer")

        if (container) {
          container.style.display = "none"
        }

        document.body.style.overflow = ""
      }, 300)
    }
  }

  static showWarningModal(exploit) {
    const warningModal = document.getElementById("warningModal")
    const warningText = document.getElementById("warningModalText")
    const cancelBtn = document.getElementById("warningModalCancel")
    const okayBtn = document.getElementById("warningModalOkay")
    const targetUrl = exploit.href

    warningText.textContent = exploit.warningInfo || "Are you sure you want to visit this website?"
    warningModal.style.display = "flex"
    document.body.style.overflow = "hidden"

    void warningModal.offsetWidth
    warningModal.classList.add("active")

    const cleanup = () => {
      warningModal.classList.remove("active")

      setTimeout(() => {
        warningModal.style.display = "none"
        document.body.style.overflow = ""
      }, 300)
    }

    cancelBtn.onclick = () => {
      cleanup()
    }

    okayBtn.onclick = () => {
      cleanup()

      if (targetUrl) {
        window.open(targetUrl, "_blank")
      }
    }
  }
}

class ThemeManager {
  constructor() {
    this.currentTheme = localStorage.getItem("voxlis-theme") || "classic"
  }

  init() {
    document.documentElement.setAttribute("data-theme", this.currentTheme)

    this.setupThemeDropdown()
    this.updateThemeElements()

    return this
  }

  setupThemeDropdown() {
    const themeDropdown = document.getElementById("themeDropdown")
    const themeDropdownSelected = document.getElementById("themeDropdownSelected")
    const themeDropdownOptions = document.getElementById("themeDropdownOptions")

    if (themeDropdown && themeDropdownSelected && themeDropdownOptions) {
      this.updateSelectedTheme(document.documentElement.getAttribute("data-theme") || "classic")

      themeDropdownSelected.addEventListener("click", () => {
        themeDropdown.classList.toggle("active")
      })

      document.addEventListener("click", (e) => {
        if (!themeDropdown.contains(e.target)) {
          themeDropdown.classList.remove("active")
        }
      })

      const themeOptions = themeDropdownOptions.querySelectorAll(".theme-dropdown-option")

      themeOptions.forEach((option) => {
        option.addEventListener("click", () => {
          const theme = option.getAttribute("data-theme")
          document.documentElement.setAttribute("data-theme", theme)
          this.currentTheme = theme
          this.updateSelectedTheme(theme)
          localStorage.setItem("voxlis-theme", theme)
          themeDropdown.classList.remove("active")
          this.createThemeChangeEffect(theme)
          setTimeout(() => this.updateThemeElements(), 100)
        })
      })
    }
  }

  updateSelectedTheme(theme) {
    const themeDropdownSelected = document.getElementById("themeDropdownSelected")
    const themeDropdownOptions = document.getElementById("themeDropdownOptions")

    if (themeDropdownSelected && themeDropdownOptions) {
      const themeName = theme.charAt(0).toUpperCase() + theme.slice(1)

      themeDropdownSelected.innerHTML = `
    <div class="theme-color-indicator ${theme}"></div>
    <span>${themeName} Theme</span>
    <i class="fas fa-chevron-down"></i>
  `

      const options = themeDropdownOptions.querySelectorAll(".theme-dropdown-option")

      options.forEach((option) => {
        option.classList.remove("selected")

        if (option.getAttribute("data-theme") === theme) {
          option.classList.add("selected")
        }
      })
    }
  }

  createThemeChangeEffect(theme) {
    const themeColor = getComputedStyle(document.documentElement).getPropertyValue("--theme-color").trim()

    const ripple = document.createElement("div")
    ripple.style.position = "fixed"
    ripple.style.top = "50%"
    ripple.style.left = "50%"
    ripple.style.transform = "translate(-50%, -50%)"
    ripple.style.width = "10px"
    ripple.style.height = "10px"
    ripple.style.borderRadius = "50%"
    ripple.style.backgroundColor = themeColor
    ripple.style.opacity = "0.3"
    ripple.style.transition = "all 0.6s cubic-bezier(0.19, 1, 0.22, 1)"
    ripple.style.zIndex = "9999"

    document.body.appendChild(ripple)

    setTimeout(() => {
      ripple.style.width = "300vw"
      ripple.style.height = "300vh"
      ripple.style.opacity = "0"
    }, 10)

    setTimeout(() => {
      ripple.remove()
    }, 800)
  }

  updateThemeElements() {
    const theme = this.currentTheme
    let bgColor, textColor, borderColor

    switch (theme) {
      case "red":
        bgColor = "#371616"
        textColor = "#f87171"
        borderColor = "#f8717166"
        break
      case "blue":
        bgColor = "#1e3a8a"
        textColor = "#60a5fa"
        borderColor = "#60a5fa66"
        break
      case "green":
        bgColor = "#1a2e21"
        textColor = "#86efac"
        borderColor = "#86efac66"
        break
      case "yellow":
        bgColor = "#332618"
        textColor = "#fde047"
        borderColor = "#fde04766"
        break
      case "purple":
        bgColor = "#28183c"
        textColor = "#c084fc"
        borderColor = "#c084fc66"
        break
      case "classic":
      default:
        bgColor = "#000000"
        textColor = "#ef4444"
        borderColor = "#f8717166"
    }

    const infoModal = document.querySelector(".info-modal")

    if (infoModal) {
      const header = infoModal.querySelector(".info-modal-header")
      if (header) {
        header.style.background = ""
        header.style.borderBottom = ""
      }

      const exploitName = infoModal.querySelector(".info-modal-exploit-name")
      if (exploitName) {
        exploitName.style.background = ""
      }

      const closeBtn = infoModal.querySelector(".info-modal-close-btn")
      if (closeBtn) {
        closeBtn.style.backgroundColor = ""
      }

      const links = infoModal.querySelectorAll(".info-modal-markdown a")
      links.forEach((link) => {
        link.style.color = ""
      })

      const blockquote = infoModal.querySelectorAll(".info-modal-markdown blockquote")
      blockquote.forEach((bq) => {
        bq.style.backgroundColor = ""
        bq.style.borderColor = ""
        bq.style.color = ""
      })

      const codeBlocks = infoModal.querySelectorAll(".info-modal-markdown pre code")
      codeBlocks.forEach((codeBlock) => {
        codeBlock.style.background = ""
        codeBlock.style.color = ""
      })
    }

    const webButtons = document.querySelectorAll(".web-btn")
    webButtons.forEach((btn) => {
      btn.style.backgroundColor = ""
      btn.style.borderColor = ""
      btn.style.color = ""
    })

    const heroElements = document.querySelectorAll(
      ".hero-acnt-bar, .hero-ttl strong, .hero-ttl b, .hero-ttl em, .yt-tutorial-btn",
    )

    heroElements.forEach((el) => {
      el.style.background = ""
      el.style.color = ""
    })

    const checkboxes = document.querySelectorAll(
      ".cstm-chkbx.ext input:checked ~ .chkmrk, .cstm-chkbx.exec input:checked ~ .chkmrk",
    )

    checkboxes.forEach((cb) => {
      cb.style.backgroundColor = ""
      cb.style.borderColor = ""
    })
  }
}

class OptimizedHeartAnimation {
  constructor() {
    this.canvas = document.getElementById("heartRainCanvas")
    this.loader = document.getElementById("loader")

    if (!this.canvas) return

    this.ctx = this.canvas.getContext("2d")
    this.heartImageSrc = "/assets/heart.svg"
    this.hearts = []
    this.heartImage = new Image()
    this.isRunning = false
    this.lastFrameTime = 0
    this.lastFpsUpdate = 0
    this.frameCount = 0
    this.fps = 0
    this.targetFps = 30
    this.fpsInterval = 1000 / this.targetFps

    this.resizeCanvas()
    window.addEventListener("resize", this.resizeCanvas.bind(this))

    this.heartImage.src = this.heartImageSrc
    this.heartImage.onload = () => {
      if (this.loader) this.loader.style.display = "none"
      this.numHearts = this.calculateNumHearts()
      for (let i = 0; i < this.numHearts; i++) {
        this.hearts.push(this.createHeart())
      }
      this.start()
    }

    this.heartImage.onerror = () => {
      console.error(`Failed to load heart image: ${this.heartImageSrc}`)
      if (this.loader) this.loader.textContent = "Failed to load animation assets."
    }

    this.canvas.addEventListener("click", this.handleClick.bind(this))
  }

  calculateNumHearts() {
    const area = this.canvas.width * this.canvas.height
    const density = 50000
    return Math.max(10, Math.round(area / density))
  }

  resizeCanvas() {
    if (!this.canvas) return
    const oldWidth = this.canvas.width || window.innerWidth
    const oldHeight = this.canvas.height || window.innerHeight

    this.canvas.width = window.innerWidth
    this.canvas.height = window.innerHeight

    if (this.hearts.length && oldWidth && oldHeight) {
      const scaleX = this.canvas.width / oldWidth
      const scaleY = this.canvas.height / oldHeight
      this.hearts.forEach((heart) => {
        heart.x *= scaleX
        heart.y *= scaleY
      })
    }

    const newCount = this.calculateNumHearts()
    if (newCount > this.hearts.length) {
      const toAdd = newCount - this.hearts.length
      for (let i = 0; i < toAdd; i++) {
        this.hearts.push(this.createHeart())
      }
    } else if (newCount < this.hearts.length) {
      this.hearts.splice(newCount)
    }
    this.numHearts = newCount
  }

  createHeart() {
    return {
      img: this.heartImage,
      x: Math.random() * this.canvas.width,
      y: Math.random() * this.canvas.height,
      dx: Math.random() * 0.4 - 0.2,
      dy: Math.random() * 0.3 + 0.2,
      size: Math.random() * 15 + 15,
      rotation: Math.random() * 0.2 - 0.1,
      rotationSpeed: Math.random() * 0.005 - 0.0025,
      opacity: Math.random() * 0.3 + 0.7,
    }
  }

  start() {
    if (this.isRunning) return
    this.isRunning = true
    this.lastFrameTime = performance.now()
    this.lastFpsUpdate = this.lastFrameTime
    requestAnimationFrame(this.animate.bind(this))
  }

  stop() {
    this.isRunning = false
  }

  animate(timestamp) {
    if (!this.isRunning) return
    const elapsed = timestamp - this.lastFrameTime
    if (elapsed > this.fpsInterval) {
      this.lastFrameTime = timestamp - (elapsed % this.fpsInterval)
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)

      for (const heart of this.hearts) {
        heart.x += heart.dx
        heart.y += heart.dy
        heart.rotation += heart.rotationSpeed

        if (heart.y > this.canvas.height + heart.size) {
          heart.y = -heart.size
          heart.x = Math.random() * this.canvas.width
          heart.dy = Math.random() * 0.3 + 0.2
        }
        if (heart.x < -heart.size) heart.x = this.canvas.width + heart.size
        if (heart.x > this.canvas.width + heart.size) heart.x = -heart.size

        this.ctx.save()
        this.ctx.translate(heart.x, heart.y)
        this.ctx.rotate(heart.rotation)
        this.ctx.globalAlpha = heart.opacity
        this.ctx.drawImage(heart.img, -heart.size / 2, -heart.size / 2, heart.size, heart.size)
        this.ctx.restore()
      }

      this.frameCount++
      if (timestamp - this.lastFpsUpdate > 1000) {
        this.fps = Math.round((this.frameCount * 1000) / (timestamp - this.lastFpsUpdate))
        this.frameCount = 0
        this.lastFpsUpdate = timestamp
      }
    }
    requestAnimationFrame(this.animate.bind(this))
  }

  handleClick(e) {
    const clickHeartsCount = Math.floor(Math.random() * 3) + 3
    for (let i = 0; i < clickHeartsCount; i++) {
      this.hearts.push({
        img: this.heartImage,
        x: e.clientX + (Math.random() * 40 - 20),
        y: e.clientY + (Math.random() * 40 - 20),
        dx: Math.random() * 1 - 0.5,
        dy: Math.random() * 0.5 - 1,
        size: Math.random() * 40 + 60,
        rotation: Math.random() * 0.2 - 0.1,
        rotationSpeed: Math.random() * 0.01 - 0.005,
        opacity: Math.random() * 0.3 + 0.7,
      })
    }
  }
}

class LoadingManager {
  constructor(appState) {
    this.appState = appState
    this.loadingBar = document.getElementById("loadingBar")
    this.loadingScreen = document.getElementById("loadingScreen")
    this.loadingText = document.querySelector(".loading-text")
  }

  init() {
    let progress = 0
    const startTime = performance.now()
    const deviceTier = this.appState.performanceMonitor.deviceTier

    const isSlowDevice = () => this.appState.performanceMonitor.isLowEndDevice
    const incrementAmount = isSlowDevice() ? 2 : deviceTier === "medium" ? 4 : 8
    const incrementInterval = isSlowDevice() ? 150 : deviceTier === "medium" ? 100 : 60

    if (this.loadingText) {
      this.loadingText.textContent = `Detecting device performance (${deviceTier})...`
    }

    const loadingInterval = setInterval(() => {
      if (progress < 100) {
        progress += incrementAmount

        if (progress > 100) progress = 100

        requestAnimationFrame(() => {
          if (this.loadingBar) this.loadingBar.style.width = `${progress}%`
        })

        if (this.loadingText) {
          if (progress < 30) {
            this.loadingText.textContent = `Loading resources (${deviceTier} mode)...`
          } else if (progress < 60) {
            this.loadingText.textContent = `Preparing exploits (${deviceTier} mode)...`
          } else if (progress < 90) {
            this.loadingText.textContent = `Almost ready (${deviceTier} mode)...`
          } else {
            this.loadingText.textContent = `Welcome to voxlis.NET (${deviceTier} mode)`
          }
        }
      } else {
        clearInterval(loadingInterval)

        setTimeout(
          () => {
            if (this.loadingScreen) {
              this.loadingScreen.style.transition = "opacity 0.8s ease, visibility 0.8s ease"
              this.loadingScreen.style.opacity = "0"
              this.loadingScreen.style.visibility = "hidden"

              setTimeout(() => {
                this.loadingScreen.remove()
              }, 800)
            }
          },
          isSlowDevice() ? 1000 : deviceTier === "medium" ? 600 : 300,
        )
      }
    }, incrementInterval)

    return this
  }
}

document.addEventListener("DOMContentLoaded", () => {
  const appState = new AppState().init()
  const uiManager = new UIManager(appState).init()
  const themeManager = new ThemeManager().init()
  const loadingManager = new LoadingManager(appState).init()
  const heartAnimation = new OptimizedHeartAnimation()

  setTimeout(() => {
    uiManager.setupCardButtons()
  }, 500)

  console.log(`Device performance tier: ${appState.performanceMonitor.deviceTier}`)
  console.log(`Low-end device: ${appState.performanceMonitor.isLowEndDevice ? "Yes" : "No"}`)
})
