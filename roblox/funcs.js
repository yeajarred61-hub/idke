const expData = [
  {
    id: "zenith",
    name: "Zenith",
    desc: "The best overall value exploit.",
    lvl: 8,
    price: "$6.49",
    period: "weekly",
    plat: ["windows", "windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: true,
    hasKeySystem: false,
    free: false,
    pricegray: false,
    info: "## Exploit Performance  \n- [Zenith](/) functions similarly to the old [Nihon](/) executor, as it shares the same development team but has been rebranded. The main distinction is that [Zenith](/) is actively maintained, whereas [Nihon](/) is still undergoing redevelopment. [Zenith](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files. [Swift]() is technically [Zenith]() as they share some code modules, so they might perform similarly. Apart from that, [voxlis NETWORK]() recommends this executor; it's close to perfection.\n  \n\n## Background Information  \n- Before [Zenith](/), an executor - [Nihon](/) launched in early 2024 and officially released on October 24, 2024, delivering strong performance. On February 3, 2025, [Nihon](/) team splited. The [Nihon](/) owner commented on the situation: *\"A former admin and Sero nuked the server and banned users. We're restoring it—Zenith wasn't involved and even returned our vanity. ❤️\"*. No further details were provided, though the situation is likely more complex.  \n\n## Developers Background Information\n- There is little background information available about the owners, [@Immune](/), aside from their primary role in working on the UI for [Nihon](/). The rest of the development team included [@loadnil](/), [@mcgamin1738](/) and [@lendmeyourstrength](), who were primarily responsible for both the back-end and front-end development of Nihon. Later, the team was forced to leave [Nihon](/), leading the developers to found [Zenith](/), which has been doing quite well. The current main owners are [@loadnil](/), [@lendmeyourstrength](/), [@mcgamin1738](/) and [@spectraluwu]().\n\n\n> Sources: [reddit.com/r/robloxhackers](), Zenith & Nihon Developers",    href: "https://zenith.win",
    priceHref: "https://www.key-empire.com/roblox#zenith",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=5zqrO9zJvAj7tE9S&key=nqZfYyWSLt37gqeNNgT4XZy1EHovYSTm",
    hide: false,
    scrapId: "5zqrO9zJvAj7tE9S",
    key: "nqZfYyWSLt37gqeNNgT4XZy1EHovYSTm",
    widget: true,
  },
  {
    id: "severe",
    name: "Severe",
    desc: "A good external exploit.",
    external: true,
    price: "$19.99",
    period: "lifetime",
    plat: ["windows"],
    pros: ["Has a Luau environment", "Usermode product", "Rich in features"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    info: "## Exploit Performance  \n- [Severe](/) gained recognition as the first undetected external  following the rollout of [Hyperion](/) in November 2023. Since then, it has undergone continuous improvements, focusing on stability, performance, and a user-friendly interface with clean, modern visuals.  \n- The custom [Luau](/) environment built into [Severe](/) is optimized for speed and deep memory interaction, offering advanced low-level capabilities rarely seen in external executors.\n\n## Background Information  \n- [Severe](/) originated as [v-severe](/), an external that began development before [Hyperion](/) was introduced, sometime around 2021.  \n- It now includes unique features such as a 3D radar and in-menu chat — with additional enhancements planned for future releases.\n\n## Developers Background Information  \n- [Severe](/) is developed by [@BACKWOODS](/), who started his journey creating and redesigning UIs in C#. He later transitioned into exploit development, releasing [Sona](/) and [Sona One](/), two prior executors known for providing Level 6–7 execution performance.\n\n> Sources: [Severe](), internal testing, and developer notes\n",
    premium: false,
    href: "https://discord.gg/4QmWjQCgzV",
    priceHref: "https://discord.gg/4QmWjQCgzV",
    hide: false,
    hideunc: true,
    pricegray: true,
  },
  {
    id: "matrix",
    name: "Matrix",
    desc: "A cheap external exploit.",
    external: true,
    price: "$4.99",
    period: "lifetime",
    plat: ["windows"],
    pros: ["Usermode product", "Very cheap price"],
    neutral: ["Basic in features"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: false,
    href: "https://key-empire.com/roblox",
    priceHref: "http://matrixhubs.shop/",
    hide: false,
    hideunc: true,
    pricegray: true,
  },
  {
    id: "ronin",
    name: "Ronin",
    desc: "An external cheat with a Lifetime subscription.",
    price: "$12.49",
    period: "lifetime",
    plat: ["windows"],
    pros: ["Amazing optimization", "Usermode product", "Rich in features"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-purple-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: false,
    pricegray: true,
    href: "https://getronin.xyz/",
    priceHref: "https://www.key-empire.com/roblox#ronin",
    info: "## Exploit Performance  \n- [Ronin]() is an external released on March 2nd, 2025. Recently out of beta, it performs on par with other fully released competitors. Since launch, [Ronin]() has delivered stable and reliable results, with minimal complaints from users and resellers.  \n- Despite being new, [Ronin]() has already proven itself in terms of stability, efficiency, and quality. Early feedback highlights its smooth performance and solid design. It is seen as a high-potential option with strong usability and readiness for the market.\n\n## Background Information  \n- [Ronin]() is a usermode product owned by [Reaper](), who also developed [Cryptic]() and [Somber]() (formerly known as [Reaper Hub]()). It officially released on March 2nd, 2025 and is currently out of beta. Development is now led by [@Pixi]() and [@Jumble](), after [Reaper]() stepped away from direct development.  \n- The interface is written in Rust, providing a fast and efficient user experience. [Ronin]() reflects the quality expected from [Reaper]()’s projects.  \n- [Reaper]() is known for maintaining a low profile, avoiding drama, and having a clean reputation in the community. His professionalism and consistent output have earned him wide respect.\n\n## Developer Background Information  \n- [Ronin]() is currently developed by [@Pixi]() and [@Jumble](), under the ownership of [Reaper]().  \n\n> Sources: [reddit.com/r/robloxhackers](), Ronin Discord Server\n",
    hasKeySystem: false,
    free: false,
    external: true,
    hideunc: true,
  },
  {
    id: "cryptic",
    name: "Cryptic",
    desc: "An exploit for most platforms.",
    lvl: 8,
    price: "$4.99",
    period: "monthly",
    plat: ["windows", "macos", "ios", "android"],
    pros: ["Has a decompiler", "VNG Support","97% sUNC", "Level 8"],
    neutral: ["Android uses module from ArceusX"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-purple-500",
    accentColor: "from-purple-600 to-purple-700",
    premium: false,
    pricegray: true,
    href: "https://getcryptic.net/",
    priceHref: "https://key-empire.com/roblox",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=3ceXNUciuo4g64Ao&key=W0FJ6cRxGGbr19RFWXCiAjUMmYn4oUtw",
    info: "## Exploit Performance\n\n* [Cryptic]() is a sleek, modern, and entirely free Level 8 executor. It delivers smooth performance with strong script compatibility and includes a fast startup time, clean UI, and several beginner-friendly tools. [Cryptic]() is designed to be easy to use while maintaining high reliability.\n\n## Background Information\n\n* [Cryptic]() was created as a premium-quality alternative to paid executors, with an emphasis on transparency and user safety. It avoids any shady affiliations and focuses on delivering a secure experience.\n* Updates are typically released within hours of Roblox patches, ensuring minimal downtime. The Discord server is actively maintained, with channels dedicated to support, script sharing, and bug reporting.\n\n## Developer Background Information\n\n* [Cryptic]() is developed by [Reaper](), a well-respected developer in the exploiting scene. He works alongside a small, tight-knit team known for being responsive and transparent. The team is praised for their quick update cycle and commitment to user support.\n\n> Sources: [reddit.com/r/robloxhackers](), Cryptic Team",
    hasKeySystem: true,
    free: true,
  },
  {
    id: "wave",
    name: "Wave",
    desc: "Amazing exploit with regular updates.",
    lvl: 8,
    price: "$7.49",
    period: "weekly",
    plat: ["windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    premium: false,
    pricegray: true,
    href: "https://getwave.gg",
    priceHref: "https://key-empire.com/roblox#wave",
    info: "## Exploit Performance\n- [Wave]() works like a normal executor, has good uptime, but has its issues like random crashes, UI not saving tabs after closing the program, and the workspace folder not saving after updates. [Wave]() offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n\n## Background Information\n- In March 2022, [@lxnny]() — the owner of [Delta]() — reposted the CW (community warning) on [WeAreDevs.NET](), exposing ArceusX for ratting users and massively scamming their developers.\n- Originally, [Wave's]() launch was delayed and teased multiple times in their Discord server.\n  It eventually released around April 5–9, but saw very few updates early on.\n  For example, when Roblox updated on a Wednesday, Wave wouldn't get updated until Friday.\n  This pattern continued up until December 2024, sometimes with even bigger delays. Since December, [Wave]() has shown better performance and has been more consistent.\n  However, the UI and other features haven't seen much attention or updates since then.\n\n## Developers Background Information\n- Currently owned by [@Tiahh](). Developer background information is limited. Previous developers were reportedly scammed in 2021 by [ArceusX]() owners at the time, and details about the current development team are largely unknown.\n\n> Sources: [reddit.com/r/robloxhackers](), WeAreDevs.NET, Old V3rmillion.net",
    hasKeySystem: false,
    free: false,
    uncbuttonlink: "https://sunc.rubis.app/?scrap=chxc3Rtp1NOhSxAf&key=KwyQ9vNKHEL9lcCXWMNu7pFxpGrtki7q",
    warning: false,
    warningInfo:
      "voxlis.NET recommends checking out “MORE INFO” for Wave so you know what you’re getting. Would you like to continue to Wave’s website anyway?",
  },

  {
    id: "macsploit",
    name: "Macsploit",
    desc: "A powerful exploit for macOS.",
    lvl: 8,
    price: "$9.99",
    period: "lifetime",
    plat: ["macos"],
    pros: ["Multi-Inject support", "Has a Trial version", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    premium: false,
    pricegray: true,
    editor: "voxlis.NET",
    txtColor: "text-green-500",
    accentColor: "from-green-600 to-green-700",
    href: "https://www.raptor.fun/",
    priceHref: "https://key-empire.com/roblox#macsploit",
    info: "\n## Exploit Performance\n- [MacSploit]() functions like a standard executor but is designed specifically for macOS. While its stability is generally acceptable, it has experienced significant periods of downtime. Since it is macOS-exclusive, [voxlis.NET]() cannot provide a deeper assessment at this time.\n\n## Background Information\n- In 2024, the [MacSploit]() source code was leaked by [@Peyton]() after [@managedhosts]() was accused of engaging in shady behavior, including alleged involvement with loggers and other suspicious practices.\n\n\n## Developer Information\n- [MacSploit](), owned by [Raptor](), was originally founded by [@Peyton]() and [@Nexus42](). Raptor initially began as a Windows executor collection. [@Peyton]() retired from the project in 2022 but later returned and reignited activity around [MacSploit]() following concerns about how the project was being handled.\n- [@Nexus42]() is currently the lead developer of [MacSploit](). However, he has a controversial reputation due to past involvement with logging tools, and the community remains critical of his role. Other contributors include [@atomic](), [@rcloll](), and [@Kohl](), who assist with the ongoing development of the project.  \n\n> Sources: [reddit.com/r/robloxhackers](), Raptor Development Discord, Raptor\n",
    hasKeySystem: false,
    free: false,
    uncbuttonlink: "https://sunc.rubis.app/?scrap=9kH1EN8HIbXl9I2o&key=KrU695V4fbJuWZcwG9jMJen2M22mRbng",
    warning: false,
    warningInfo:
      "voxlis.NET recommends checking out “MORE INFO” for MacSploit so you know what you’re getting. Would you like to continue to MacSploit's website anyway?",
  },
      {
    id: "yerba",
    name: "Yerba",
    desc: "An external usermode product.",
    lvl: 8,
    price: "$9.99",
    period: "lifetime",
    plat: ["windows"],
    pros: ["Amazing optimization", "Usermode Product", "Has a decompiler "],
    neutral: [],
    cons: [],
    verified: true,
    premium: false,
    pricegray: true,
    editor: "voxlis.NET",
    txtColor: "text-green-500",
    accentColor: "from-green-600 to-green-700",
    info: "",
    premium: false,
    href: "https://yerba.wtf/",
    priceHref: "https://yerba.wtf/",
    hide: false,
    external: true,
    hideunc: true,
  },
  {
    id: "matcha",
    name: "Matcha",
    desc: "An external exploit with driver-based execution.",
    lvl: 8,
    price: "$9.99",
    period: "lifetime",
    plat: ["windows", "windows"],
    pros: ["Has a decompiler & code explorer", "Hybrid - kernel, usermode", "Rich in features"],
    neutral: [],
    cons: [],
    verified: true,
    premium: false,
    pricegray: false,
    editor: "voxlis.NET",
    txtColor: "text-green-500",
    accentColor: "from-green-600 to-green-700",
    info: "## Exploit Performance\n\n* [Matcha]() is widely regarded as one of the best external exploits available. It features a clean, user-friendly GUI and a solid feature set. [Matcha]() receives frequent updates and is easy to set up. Performance-wise, it runs well on nearly any machine — even CPUs released as early as 2017 can handle it without issue.\n\n## Background Information\n\n* Before [Matcha]() launched in August 2024, [Vault]() was relatively unknown in the exploiting scene. The project began as a simple external, but development significantly accelerated after [@slamfrags]() was removed from the team about four months ago.\n* Since then, [Matcha]() has seen rapid daily improvements, even with [Vault]() balancing school responsibilities. [Vain]() was appointed to manage the staff team, ensuring better coordination and internal operations.\n* The exploit originally started from a casual DM where [@slamfrags]() asked [Vault]() to build an external for Roblox. [Vault]() agreed, partly due to financial needs at the time. While [@slamfrags]() handled promotion, [Vault]() focused on development. However, over time, [@slamfrags]() became known for mismanaging funds, underpaying or outright ignoring the staff team, and showing unprofessional behavior, which led to staff members resigning.\n* Eventually, staff operations were handed over to [@vain](), who brought structure and fairness to the team. Staff members are now paid and their work is recognized. The current support team is publicly listed on [Matcha's Discord server]().\n\n## Developer Background Information\n\n* [Matcha]() is developed primarily by [Vault](), who writes the core cheat code and its security features.\n* The original management team consisted of [@geekn]() and [@slamfrags](). [@geekn]() left voluntarily, while [@slamfrags]() was removed due to being overpaid for minimal contributions and ongoing internal issues.\n* Following their removal, [Vault]() brought in close friends to help manage and support the project, which contributed to its steady and structured growth.\n\n> Sources: [reddit.com/r/robloxhackers](), Matcha Discord Moderator\n",
    premium: true,
    href: "https://discord.gg/matchalol4",
    priceHref: "https://key-empire.com/roblox#matcha",
    hide: false,
    external: true,
    hideunc: true,
  },
  {
    id: "codex",
    name: "CodeX",
    desc: "A powerful exploit with advanced features.",
    lvl: 8,
    price: "$4.97",
    period: "monthly",
    plat: ["android"],
    pros: ["Has a decompiler", "VNG Support", "Level 8"],
    neutral: ["Fails sUNC checks", "Uses core technology from ArceusX"],
    cons: [],
    verified: true,
    premium: false,
    pricegray: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-yellow-600 to-yellow-700",
    href: "https://codex.lol/",
    priceHref: "https://key-empire.com/roblox#codex",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hasKeySystem: true,
    free: true,
    hideunc: true,
  },
  {
    id: "swift",
    name: "Swift",
    desc: "The free Level 8 exploit to use.",
    lvl: 8,
    price: "FREE",
    plat: ["windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    premium: false,
    info: "## Exploit Performance\n- [Swift](/) performs reasonably well. While it occasionally experiences downtime and injection issues, it remains the best available option for Level 8 execution. Alternatives like [Argon]() and [Atlantis]() exist, but unlike those, [Swift](/) is not scamming or ratting its users.\n\n## Background Information\n- [Swift](/), originally launched as [bunni.lol](/) in May 2024, had a rocky start. It rebranded to [Swift](/) in August 2024, entering Beta and quickly building a positive reputation by offering a premium experience at no cost. In January 2025, [Swift](/) went temporarily offline due to a ROBLOX platform update. It returned in March 2025 with a major overhaul—introducing 98% sUNC compatibility, a built-in decompiler, and various improvements.\n\n\n## Developers Background Information\n\n* [Swift]() was originally owned by [@Peyton](), who joined the community in 2016 and began developing between 2021 and 2022. It was administered by [@Bass](), the owner of [Script-Ware.com]()—a project that launched in late 2020 and shut down following the introduction of Hyperion. The [Zenith]() team provided occasional support (see the Zenith card on voxlis.NET for more information). Swift is now owned by Bass, as [@Peyton]() has since left to work on [Visual]().\n\n\n\n> Sources: [reddit.com/r/robloxhackers](https://reddit.com/r/robloxhackers), bunni.lol Discord Archives, Swift Discord Archives\n",
    hasKeySystem: true,
    free: true,
    href: "https://getswift.vip/",
    priceHref: "https://getswift.vip/",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=RVFt4UcmDJGWp1WE&key=RRLzNFLtQgKeakeIZNPkjDyTJRIz2kV6",
    hide: false,
  },
  {
    id: "hydrogen",
    name: "Hydrogen",
    desc: "A free macOS Exploit",
    lvl: 8,
    price: "$4.99",
    period: "monthly",
    plat: ["macos"],
    pros: ["Has a decompiler", "96% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    href: "https://hydrogen.lat",
    priceHref: "https://hydrogen.lat",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=5qh7GIfCDb8WZjtp&key=3Hq4Uz3Oc3X9G34ROz12ODY4VJIwXuUH",
    info: "## Exploit Performance\n- Customizable themes (open-source), [Luarmor]() support, and performance comparable to a standard executor.\n\n## Background Information\n- [Hydrogen]() has been a long-standing executor for macOS and Android (now discontinued). Originally developed by [@xgladius](), it was known for being an ultra-fast macOS executor. Later, development was taken over by [@retguard](), who eventually discontinued updates in May 2024 due to personal reasons. As of April 12, 2025, [@xgladius]() has resumed development, with plans to continue its progress for the foreseeable future.\n\n## Developer Background\n- [Hydrogen]() is created by [@xgladius](), a well-known exploit developer and reverse engineer. He is recognized for projects like [luaudec](https://github.com/xgladius/luauDec) and various other contributions to the Exploit Community.\n\n> Sources: Hydrogen Staff Team\n",
    hide: false,
    hasKeySystem: true,
    free: true,
    pricegray: true,
  },
  {
    id: "seliware",
    name: "Seliware",
    desc: "A reliable exploit with excellent support.",
    lvl: 8,
    price: "$9.99",
    period: "monthly",
    plat: ["windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    premium: false,
    href: "https://seliware.com",
    priceHref: "https://key-empire.com/roblox#seliware",
    info: "## Developers Background Information  \n- [Seliware](/) is developed by two experienced programmers — [@Dx](/) and [@z33r0x](/). While little is publicly known about them, both were previously part of the development team behind [TRX](/), a widely used executor within the CIS scene before the Byfron update.\n\n## History  \n- During its closed beta phase, [Seliware](/) had four core developers: [@z33r0x](/), [@Dx](/), [@Nezy](/), and [@74235](/). However, [@Nezy](/) and [@74235](/) left the project shortly before launch, creating a competing product called [Calibri](/), which was discontinued soon after.  \n- Following its official release, [Seliware](/) introduced consistent updates and practical innovations. In January, after Microsoft patched the WinVerifyTrust hook injection method, [Seliware](/) was the third executor to push an update — following [AWP](/) and [Wave](/).  \n- In April, due to internal issues, [Seliware](/) temporarily shut down for 3 weeks. Upon reopening, all active subscriptions were compensated. Currently, it stands as the most memory-efficient paid executor, making it especially appealing for farming use cases.\n\n## Future  \n- A complete rewrite of [Seliware](/) has been underway since December and will launch as a separate product under a new name. All users with an active [Seliware](/) subscription at the time of the new release will receive a full transfer.  \n- Support for other platforms — including macOS and iOS — is also planned for future expansion.\n\n## Interesting Facts  \n- [GRH](/), the creator of [Synapse Z](/), contributed to the early development of [Seliware](/).  \n- [Seliware](/) is the second-longest surviving internal executor following the [Hyperion](/) update, outlived only by [Wave](/).\n\n> Sources: [Seliware Team](), internal notes, and public release changelogs\n",
    hide: false,
    hasKeySystem: false,
    free: false,
    pricegray: true,
  },
  {
    id: "bunni",
    name: "Bunni",
    desc: "The free Level 8 exploit to use.",
    lvl: 8,
    price: "$34.99",
    period: "lifetime",
    plat: ["windows", "macos"],
    pros: ["Has a decompiler", "100% sUNC", "Level 8"],
    neutral: ["Check 'More Info' -> Exploit Performance"],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    premium: true,
    href: "https://discord.gg/bunnilol",
    priceHref: "https://key-empire.com/roblox#bunni",
    info: "## Exploit Performance\n\n* Multiple stability issues. You must have [VcRedist x64](https://aka.ms/vs/17/release/vc_redist.x64.exe) & [VcRedist x86](https://aka.ms/vs/17/release/vc_redist.x86.exe) installed to pass the UI, and a reasonably capable CPU. We tested this executor on an [i5-4460](). After the injection, the client’s performance dropped severely — mouse and keyboard input lagged by roughly 20 seconds. Other executors do not show this behavior on the same CPU. [voxlis NETWORK]() recommends this executor only for lifetime-subscription users.\n\n\n## Background Information  \n\n- Originally released under the name [Swift](), the brand was later sold and the project renamed [Bunni](). It was subsequently rebranded to [Visual]() for a short period before returning to the [Bunni]() name. For a fuller timeline and source details, consult the Swift and MacSploit cards.\n\n\n## Developer Information  \n- [Peyton](/), the project’s creator, is an experienced and respected developer in the exploit community. His track record includes continued leadership on [Swift](/), while now also overseeing Visual’s direction. [Blinx](/), the UI designer behind both the original Swift interface and Visual’s current look, brings a clean and consistent visual identity across projects. [Reveny](/) and [Viz](/), both software engineering majors and longtime collaborators of Peyton, contribute to the development of Visual. Though not publicly known in the community, their technical expertise ensures the project is both scalable and dependable.\n\n> Sources: Reddit.com/r/robloxhackers, Swift Discord, Visual Discord, Bunni Discord",
    hasKeySystem: true,
    free: true,
    pricegray: false,
    hide: false,
  },
  {
    id: "krnl",
    name: "KRNL",
    desc: "A popular free exploit with good performance.",
    lvl: 8,
    price: "FREE",
    plat: ["android", "ios"],
    pros: ["Has a decompiler", "VNG Support", "80% sUNC", "Level 8"],
    neutral: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    href: "https://krnl.cat",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=gNoCwGOBq1R9ZIt4&key=tgUr5UqU637uvDAsbISvVzaixt2Gkr4F",
    info: "## Exploit Performance  \n- [KRNL]() runs smoothly as an Android exploit and performs well for a free tool. Occasionally, it may have issues with the [MuMu]() emulator—using a different emulator can improve stability.\n\n## Background Information  \n- Developed around 2019 by [Ice Bear](), [KRNL]() gained popularity through [WeAreDevs](), despite the site’s mixed reputation. It became one of the most-used free executors, often rivaling paid options.  \n- After Roblox introduced [Hyperion]() (Byfron’s anti-cheat), [KRNL]() paused updates. It briefly supported UWP (Microsoft Store Roblox), which lacked [Byfron]() protection at the time, but support ended once [Byfron]() was added to UWP.\n\n## Developer Background  \n- Created by [Ice Bear](), known for delivering stable tools. In late 2024, [KRNL]() was sold to [@valentinodev](), who now leads its development.\n\n> Sources: [reddit.com/r/robloxhackers]()\n",
    hasKeySystem: true,
    free: true,
  },
  {
    id: "solara",
    name: "Solara",
    desc: "A free exploit with decent performance.",
    lvl: 3,
    price: "FREE",
    plat: ["windows"],
    pros: ["Has a decompiler", "No keysystem", "51% sUNC~"],
    neutral: ["Level 3"],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    href: "https://getsolara.dev",
    info: "## Exploit Performance \n- [Solara]() offers solid performance with minimal crashes or instability, making it a reliable option for most users. It receives fast and frequent updates, keeping up with Roblox patches to reduce downtime.\n- Unlike many executors that rely on complicated key systems, [Solara]() simplifies access by requiring users to complete a quick Linkvertise task during download, making setup more user-friendly.\n\n## Background Information \n- [Solara]() is owned and managed by [@quivings](), who was previously active in the script development scene.\n- While not much is publicly known about him, [@quivings]() has built a respectable reputation within the community for his work and consistent updates to the tool.\n",
    hasKeySystem: false,
    free: true,
  },
  {
    id: "delta",
    name: "Delta",
    desc: "A powerful multi-platform exploit.",
    lvl: 8,
    price: "FREE",
    plat: ["ios", "android"],
    pros: ["Has a decompiler", "100% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    href: "https://deltaexploits.gg",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=YjWxOsGMMsBpfHlK&key=pZ1KPbSD5egMFjZT2wWV9vTU6iHirhhQ",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hide: false,
    hasKeySystem: true,
    free: true,
  },
  {
    id: "xeno",
    name: "Xeno",
    desc: "A free exploit with basic features.",
    lvl: 3,
    price: "FREE",
    plat: ["windows"],
    pros: ["Has a decompiler", "No keysystem", "40% sUNC~"],
    neutral: ["Level 3"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    href: "https://www.xeno.onl/",
    priceHref: "https://linkvertise.com/1319977/xeno",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hide: false,
    hasKeySystem: false,
    free: true,
  },
  {
    id: "velocity",
    name: "Velocity",
    desc: "A new free exploit with good performance.",
    lvl: 8,
    price: "FREE",
    plat: ["windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "No keysystem", "98% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    href: "https://getvelocity.lol/",
    priceHref: "https://yap.com/",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=6FDtZtu9TkmK4Brn&key=pfNjgR1vhCircX6AI2i54oOBtBIzYbWk",
    info: "## Exploit Performance  \n- [Velocity](/) is a stable and powerful free executor with a modern backend, custom key system, and active maintenance. It delivers fast performance, regular updates, and a smooth user experience driven by community feedback.\n\n## Background Information  \n- [Velocity](/) started as [CGHub](/), a tool by [CG](/), and later became [Sonar](/). Originally a test project, it gained 20,000 users in its first week, leading to its full release and rebrand to [Velocity](/) on January 9, 2025.\n\n## Discord Server & Community  \n- Early support was unorganized with tickets flooding chat, later fixed by a dedicated server. After a short decline, new staff restored order. The community played a big role early on, and [Korabi](/) later overhauled the project with a new site, backend, key system, and moderation—pushing [Velocity](/) to the top.\n\n> Sources: [reddit.com/r/robloxhackers](), Velocity Developers\n",
    hide: false,
    hasKeySystem: false,
    free: true,
    hide: false,
  },
  {
    id: "serotonin",
    name: "Serotonin",
    desc: "A usermode external exploit",
    lvl: 8,
    price: "$9.99",
    plat: ["windows"],
    external: true,
    pros: ["Has a Lua env & code explorer", "Usermode product", "Rich in features"],
    neutral: [],
    cons: [],
    verified: true,
    edito: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-red-600 to-red-700",
    info: "# Exploit Performance\n\n[Serotonin ](url)is an external cheat that has quickly gained a strong reputation from a development standpoint. It offers many unique features, including a **3D ESP Preview**, a **first** for external cheats on Roblox, which is fully modular, allowing all elements to be adjusted. Other notable features include a **Player Avatar/Mesh preview** to visualize meshes and players which has **never been done before**, and **Highlight/Mesh chams** that rival internal visuals. [Serotonin ](url)also provides a **globally functional vis check** and lighting modules that work in almost all games. The development team maintains a consistent weekly update schedule.\n\n## Background Information\n\n[Serotonin ](url)was launched by developer [@Auti](url), who branched off from a previous private project called **Melatonin**. During a year and a half at Melatonin, [Auti ](url)developed cheats for **Roblox, FiveM, Battlefield, CS:S, Rust DMA, and Apex DMA**. While there, [Auti](url) was responsible for releasing the **first external visibility check** to the public and enabling access to Instance Attributes through the external's Lua VM. When starting [Serotonin](url), [Auti](url) partnered with his friend [@Fope](url), who is the UI creator and designer for the menu. [Fope](url) plans on releasing his **CS:2** Product and eventually expanding onto other games.\n\n## Developer Insight\n\n- [Serotonin ](url)Roblox is developed by [Auti](url), who has approximately **five to six years of experience** in reverse engineering across numerous games. \n- Auti occasionally posts Devlogs to his [YouTube channel](https://www.youtube.com/@autihvh)\n- The UI and menu design are created by Fope, his partner.",
    href: "https://serotonin.win/",
    priceHref: "https://key-empire.com/roblox#serotonin",
    hide: false,
    period: "monthly",
    pricegray: true,
  },

  {
    id: "vegax",
    name: "VegaX",
    desc: "A powerful exploit with short key duration.",
    lvl: 8,
    price: "FREE",
    plat: ["android"],
    pros: ["2 day long keys", "Level 8"],
    neutral: ["Fails sUNC checks", "Uses core technology from ArceusX"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-purple-500",
    accentColor: "from-purple-600 to-purple-700",
    href: "https://vegax.gg",
    priceHref: "https://yap.com/",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hide: false,
    hasKeySystem: true,
    free: true,
  },
  {
    id: "volcano",
    name: "Volcano",
    desc: "A free exploit with good performance.",
    lvl: 8,
    price: "FREE",
    plat: ["windows"],
    pros: ["Has a decompiler", "94% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    href: "https://volcano.wtf",
    priceHref: "https://key-empire.com/roblox#volcano",
    uncbuttonlink: "https://sunc.rubis.app/?scrap=LQ8uphMkPlKrqKgY&key=wE4Rjq07vQ4dfsHh6a0dxX4A47q1ijaE",
    info: "## Exploit Performance\n- Oops! 🤭,Looks like we had not gathered the information yet on this Exploit! This could take some time to finish... If you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!\n\n## Background Information\n- Oops! 🤭,Looks like we had not gathered the information yet on this Exploit! This could take some time to finish... If you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!\n\n\n## Developers Background Information\n- Oops! 🤭,Looks like we had not gathered the information yet on this Exploit! This could take some time to finish... If you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!\n\n> Sources: [reddit.com/r/robloxhackers](), WeAreDevs.NET, Old V3rmillion.net",
    hasKeySystem: true,
    free: true,
    hide: false,
  },
  {
    id: "dx9ware",
    name: "DX9WARE",
    desc: "An external software.",
    lvl: 6,
    price: "$3.25",
    period: "weekly",
    plat: ["windows"],
    pros: ["Has a decompiler & code explorer", "Rich in features", "Kernel product"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-red-500",
    accentColor: "from-red-600 to-red-700",
    href: "https://cultofintellect.com/",
    priceHref: "https://cultofintellect.com/",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hide: false,
    hasKeySystem: false,
    free: false,
    pricegray: true,
    external: true,
    hideunc: true,
  },

  {
    id: "sirhurt",
    name: "SirHurt",
    desc: "An exploit thats been around since 2015",
    lvl: 8,
    price: "$2.80",
    period: "weekly",
    plat: ["windows"],
    pros: ["Has a decompiler", "97% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-yellow-600 to-yellow-700",
    info: '## Exploit Performance  \n- [SirHurt](https://sirhurt.net/) is a Level 8 executor with 93% sUNC compatibility. It performs consistently and supports a wide range of scripts.  \n\n## Background Information  \n- [SirHurt]() was originally launched in December 2015 as a private cheat under the name “AssHurt.” It was later renamed to "SirHurt" to make the product more marketable, particularly to younger users and their parents.  \n- Due to the shutdown of [V3rmillion.net](), much of its early history has been lost, though the executor has continued to receive updates and maintain relevance in the community for nearly a decade.  \n- The exploit is maintained by [IcePools](), who leads both development and operations. Past contributors include Woffle and Aero, though their current involvement is unclear.\n\n## Developer Background  \n- [IcePools]() is the main developer and operator of [SirHurt](). While there have been community warnings in the past—mainly regarding personal allegations—no verifiable evidence has been presented.  \n- A counter-CW was posted on [V3rm.net]() which addressed and debunked the original claims using archived material. The community generally considers the matter resolved.\n\n> Submitted by: **@daxhascool** (Public Relations at SirHurt)  \n> Sources: [reddit.com/r/robloxhackers]()\n',
    premium: false,
    href: "https://sirhurt.net",
    priceHref: "https://sirhurt.net",
    hide: false,
    warning: false,
    warningInfo:
      "voxlis.NET recommends checking out “MORE INFO” for Potassium so you know what you’re getting. Would you like to continue to Potassium's website anyway?",
    pricegray: true,
  },
  {
    id: "aimmy",
    name: "Aimmy",
    desc: "An AI-based exploit with support for multiple games.",
    external: true,
    price: "FREE",
    plat: ["windows"],
    pros: ["Supports other games", "No keysystem", "AI-based"],
    neutral: ["Requires GTX 1050 or better", "Requires training the model"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-green-500",
    accentColor: "from-green-600 to-green-700",
    href: "https://aimmy.dev",
    priceHref: "https://yap.com/",
    info: "## Oops! 🤭\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
    hide: false,
    hasKeySystem: false,
    free: true,
    hideunc: true,
  },

  {
    id: "potassium",
    name: "Potassium",
    desc: "An exploit with Lifetime license.",
    lvl: 8,
    price: "$20.00",
    period: "lifetime",
    plat: ["windows"],
    pros: ["Multi-Inject support", "Has a decompiler", "96% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: false,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-yellow-600 to-yellow-700",
    info: "## Exploit Performance  \n- [Potassium](/) offers a smooth experience and is bundled into a single `.exe` file, unlike many other exploits that come in `.zip` archives with multiple `.dll` files.\n\n## Background Information  \n- Developers operate under fresh accounts. Identities are unknown.\n\n\n## Developer Background  \n- Developers operate under fresh accounts. Identities are unknown.\n\n> Sources: [reddit.com/r/robloxhackers]()\n",
    premium: false,
    href: "https://discord.gg/WY4juPkFv4",
    priceHref: "https://key-empire.com/roblox#potassium",
    uncbuttonlink:
      "https://rubis.numelon.com/sunc-result/?scrap=NhyWN1c9glakIDfT&accessKey=fkCC9lKOKZZZSfBRHimUtJFq32PucJNe",
    hide: false,
    warning: true,
    warningInfo:
      "voxlis.NET has flagged this executor as potentially suspicious and does not recommend its use. Do you still want to proceed to the executor?",
    pricegray: true,
  },

  {
    id: "arceusx",
    name: "ArceusX",
    desc: "A long-standing mobile exploit.",
    lvl: 8,
    price: "FREE",
    price: "$7.49",
    period: "monthly",
    plat: ["ios", "android"],
    pros: ["VNG Support", "Level 8"],
    neutral: ["Fails sUNC checks"],
    cons: [],
    verified: true,
    editor: "voxlis.NET",
    txtColor: "text-yellow-500",
    accentColor: "from-yellow-600 to-yellow-700",
    info: "## Exploit Performance  \n- [ArceusX]() can run most scripts due to its high UNC percentage but lacks support for some functions like `getinstance`. Alternatives like [KRNL](https://krnl.cat) and [Delta](https://deltaexploits.gg) offer slightly better UNC and have safer reputations.\n\n## Background Information  \n- Released in 2019, [ArceusX]() was one of the first mobile Roblox executors. In March 2022, [@lxnny]() — owner of [Delta](https://deltaexploits.gg) — reposted a community warning on [WeAreDevs](https://wearedevs.net), exposing [ArceusX]() for ratting users and scamming developers. Despite this, it remains widely used. In April 2024, [SPDMTeam](https://spdmteam.com) launched [Wave](https://getwave.gg), a Windows executor combining [ArceusX]() and CodeX with an improved UI. While trusted, it’s still owned by the same team involved in past data issues. [ArceusX]() continues to receive regular updates.\n\n## Developer Background Information  \n- [ArceusX]() is owned by [Tiahh]() and [SPDMTeam](https://spdmteam.com). There is limited public information about the developers.\n\n> Sources: [reddit.com/r/robloxhackers]()\n",
    premium: false,
    href: "https://spdmteam.com/",
    priceHref: "https://key-empire.com/roblox#arceusx",
    hide: false,
    hasKeySystem: true,
    hideunc: true,
    free: false,
    warning: false,
    warningInfo:
      "voxlis.NET recommends checking out “MORE INFO” for ArceusX NEO so you know what you’re getting. Would you like to continue to ArceusX NEO's website anyway?",
    pricegray: true,
  },
  {
    id: "lx63",
    name: "LX63",
    desc: "A level 8 keyless exploit.",
    lvl: 8,
    price: "FREE",
    plat: ["windows"],
    pros: ["Has a decompiler", "No keysystem", "95% sUNC", "Level 8"],
    neutral: [],
    cons: [],
    verified: false,
    editor: "voxlis.NET",
    txtColor: "text-blue-500",
    accentColor: "from-blue-600 to-blue-700",
    info: "## Exploit Performance\n- [LX63](/) is a stable, powerful keyless executor that usually delivers strong performance and good uptime but can occasionally fail during injection and has suffered multi-week outages.\n\n## Background Information\n- 2020: launched as an [Axon fork]() and keyless executor, later became an API executor; 2022: discontinued; 2025: returned as a [Xeno paste](); initial 2025 release was discovered to be a [Visual]() paste, prompting a rushed rewrite that reduced functionality, and a new rewrite is currently underway.\n## Developers Background Information\n- [@LX63Manager](): listed original owner (identity unknown); [@kizagan]() ([@Anthares]()): co-owner active since 2020; [@Lol-AVL](): co-owner and CS2 cheat developer (identity unknown); LX63 Discord staff mainly lesser-known members with notable figures like [@Munchen]() and [@Miguel]() on the team.\n",
    premium: false,
    hasKeySystem: false,
    href: "https://lx63.xyz",
    priceHref: "",
    hide: false,
    uncbuttonlink: "https://sunc.rubis.app/?scrap=Cn5a1onS77Opiv8p&key=aDMDoLP6KcKDc8aR04ayqU1K7yjg27LP",
    free: true,
    warning: false,
    warningInfo:
      "voxlis.NET recommends checking out “MORE INFO” for RatWare so you know what you’re getting. Would you like to continue to Rat-Ware's website anyway?",
      hide: false,
  },
]

const configData = {
  theme: "dark",
  version: "1.2.3",
  _p1: "aHR0cHM6",
  debug: false,
  timeout: 5000,
}

const robloxVersionData = {
  windows: null,
  lastUpdated: null,
}

async function fetchRobloxVersion() {
  const response = await fetch("https://api.voxlis.net/roblox_version")
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }
  const data = await response.json()
  robloxVersionData.windows = data.windows
  robloxVersionData.lastUpdated = data.lastUpdated
}

const globalStatusCache = new Map()
let statusCacheTimestamp = 0
const STATUS_CACHE_DURATION = 5 * 60 * 1000

async function computeFingerprint() {
  const fpData = [
    navigator.userAgent,
    navigator.language,
    screen.width + "x" + screen.height,
    Intl.DateTimeFormat().resolvedOptions().timeZone || "",
    navigator.platform,
  ].join("||")
  if (window.crypto && crypto.subtle && crypto.subtle.digest) {
    const enc = new TextEncoder()
    const buf = await crypto.subtle.digest("SHA-256", enc.encode(fpData))
    const arr = Array.from(new Uint8Array(buf))
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("")
  }
  return fpData
}

let globalClickCounts = {}

async function fetchAllExploitStatuses() {
  const now = Date.now()

  if (globalStatusCache.size > 0 && now - statusCacheTimestamp < STATUS_CACHE_DURATION) {
    return globalStatusCache
  }

  const statusEndpoint = "https://api.voxlis.net/list"

  try {
    const response = await fetch(statusEndpoint)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    const platformFirstData = await response.json()
    globalStatusCache.clear()
    statusCacheTimestamp = now

  for (const exploit of expData) {
    const exploitStatuses = {}

    for (const platform of exploit.plat) {
      if (platformFirstData.hasOwnProperty(platform) && platformFirstData[platform].hasOwnProperty(exploit.id)) {
        const exploitData = platformFirstData[platform][exploit.id]
        exploitStatuses[platform] = exploitData?.updated === true
      }
    }
    globalStatusCache.set(exploit.id, exploitStatuses)
  }

    return globalStatusCache
  } catch (error) {
    console.error("Failed to fetch exploit statuses:", error)

    for (const exploit of expData) {
      globalStatusCache.set(exploit.id, "unknown")
    }
    return globalStatusCache
  }
}

async function getExploitStatus(exploitId) {
  if (globalStatusCache.has(exploitId)) {
    return globalStatusCache.get(exploitId)
  }

  await fetchAllExploitStatuses()

  return globalStatusCache.get(exploitId) || "unknown"
}

async function updateExploitStatusAndVersion(exploit) {
  return await getExploitStatus(exploit.id)
}

class APIClient {
  constructor() {
    this.apiUrl = "https://api.voxlis.net/api.php"
    this.sessionId = ""
    this.sessionSecret = ""
    this.nonce = ""
    this.token = ""
    this.tokenExpiry = 0
    this.initialized = false
    this.powToken = ""
  }

  async initialize() {
    if (this.initialized) return
    const res = await fetch(`${this.apiUrl}?action=init_session`, {
      method: "GET",
      credentials: "include",
    })
    if (!res.ok) throw new Error(`Session init failed: ${res.status}`)
    const data = await res.json()
    if (!data.success) throw new Error("Invalid session response")
    this.sessionId = data.data.session_id
    this.sessionSecret = data.data.session_secret
    this.nonce = data.data.nonce
    this.powToken = data.data.pow_token || ""
    this.initialized = true
  }

  async generateSignature(data) {
    if (!this.sessionSecret) throw new Error("Session secret not available")
    const encoder = new TextEncoder()
    const key = await crypto.subtle.importKey(
      "raw",
      encoder.encode(this.sessionSecret),
      { name: "HMAC", hash: "SHA-384" },
      false,
      ["sign"],
    )
    const signature = await crypto.subtle.sign("HMAC", key, encoder.encode(data))
    return Array.from(new Uint8Array(signature))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("")
  }

  async getToken() {
    if (!this.initialized) await this.initialize()
    const signature = await this.generateSignature(this.nonce)
    const headers = {
      "X-Session-Token": this.sessionId,
      "X-Nonce": this.nonce,
      "X-Signature": signature,
    }
    const res = await fetch(`${this.apiUrl}?action=get_token`, {
      method: "GET",
      credentials: "include",
      headers,
    })
    if (!res.ok) throw new Error(`Token fetch failed: ${res.status}`)
    const data = await res.json()
    if (!data.success) throw new Error("Invalid token response")
    this.token = data.data.token
    this.tokenExpiry = data.data.expires
    this.nonce = data.data.nonce
    return this.token
  }

  async solveProofOfWork() {
    if (!this.powToken) return ""
    const difficulty = 4
    const target = "0".repeat(difficulty)
    const encoder = new TextEncoder()
    let nonceInt = 0
    while (true) {
      const attempt = nonceInt.toString()
      const data = encoder.encode(this.powToken + attempt)
      const hashBuffer = await crypto.subtle.digest("SHA-256", data)
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")
      if (hashHex.startsWith(target)) {
        return attempt
      }
      nonceInt++
    }
  }

  async trackClick(itemName, buttonType) {
    if (!this.initialized) await this.initialize()
    if (!this.token || Date.now() >= this.tokenExpiry * 1000) {
      await this.getToken()
    }
    const fingerprint = await this.generateFingerprint()
    let powNonce = ""
    if (this.powToken) {
      powNonce = await this.solveProofOfWork()
    }
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.token}`,
      "X-Session-Token": this.sessionId,
      "X-Nonce": this.nonce,
    }
    try {
      const signature = await this.generateSignature(this.nonce)
      headers["X-Signature"] = signature
    } catch (e) {
      console.error("Signature generation failed:", e)
      throw new Error("Security handshake failed")
    }
    if (this.powToken && powNonce) {
      headers["X-PoW-Token"] = this.powToken
      headers["X-PoW-Nonce"] = powNonce
    }
    const res = await fetch(this.apiUrl, {
      method: "POST",
      credentials: "include",
      headers,
      body: JSON.stringify({
        item: itemName,
        button_type: buttonType,
        fingerprint: fingerprint,
      }),
    })
    if (res.status === 401) {
      await this.getToken()
      return this.trackClick(itemName, buttonType)
    }
    if (res.status === 403) {
      throw new Error("Challenge required")
    }
    if (!res.ok) throw new Error(`API error: ${res.status}`)
    const data = await res.json()
    if (data.success && data.data.nonce) {
      this.nonce = data.data.nonce
      await this.refreshClickCounts()
      return true
    }
    throw new Error("Click tracking failed")
  }

  async fetchStats() {
    if (!this.initialized) await this.initialize()
    if (!this.token || Date.now() >= this.tokenExpiry * 1000) {
      await this.getToken()
    }
    const res = await fetch(`${this.apiUrl}?action=get_stats`, {
      method: "GET",
      credentials: "include",
      headers: {
        Authorization: `Bearer ${this.token}`,
        "X-Session-Token": this.sessionId,
        "X-Nonce": this.nonce,
      },
    })
    if (!res.ok) throw new Error(`Stats fetch failed: ${res.status}`)
    const data = await res.json()
    if (data.success && data.data.stats) {
      this.nonce = data.data.nonce || this.nonce
      return data.data.stats
    }
    throw new Error("Invalid stats response")
  }

  async refreshClickCounts() {
    const stats = await this.fetchStats()
    globalClickCounts = stats
    if (window.uiManager && typeof window.uiManager.updateCounts === "function") {
      window.uiManager.updateCounts()
    }
    return stats
  }

  async generateFingerprint() {
    try {
      const parts = [
        navigator.userAgent,
        navigator.platform,
        screen.width + "x" + screen.height,
        new Date().getTimezoneOffset(),
        navigator.hardwareConcurrency || "",
        navigator.deviceMemory || "",
        screen.colorDepth,
      ].join("|")
      const buffer = new TextEncoder().encode(parts)
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer)
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")
    } catch {
      return "fp-" + Math.random().toString(36).substr(2, 10)
    }
  }
}

window.apiClient = new APIClient()

async function fetchClickCounts() {
  try {
    const stats = await window.apiClient.fetchStats()
    globalClickCounts = stats
    return stats
  } catch (e) {
    console.error("Error fetching click counts:", e)
    return {}
  }
}

function getTotalClicks(itemName) {
  const itemData = globalClickCounts[itemName]
  if (!itemData) return 0
  return (itemData.website || 0) + (itemData.price || 0)
}

const performanceConfig = {
  maxFPS: 60,
  _p2: "Ly9hcGku",
  enableOptimizations: true,
  memoryLimit: 512,
}

class ClickTracker {
  constructor() {
    this.apiEndpoint = this._buildEndpoint()
    this.initialized = false
    this.debugMode = false
  }

  _buildEndpoint() {
    const fragments = [configData._p1, performanceConfig._p2, themeSettings._p3, debugSettings._p4]
    return atob(fragments.join(""))
  }

  init() {
    if (this.initialized) return

    this.log("Initializing ClickTracker...")

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        this.log("DOM loaded, setting up tracking...")
        this.setupTracking()
      })
    } else {
      this.log("DOM already ready, setting up tracking...")
      this.setupTracking()
    }

    this.initialized = true
  }

  log(message, data = null) {
    if (this.debugMode) {
      console.log(`[ClickTracker] ${message}`, data || "")
    }
  }

  setupTracking() {
    this.log("Setting up click event listeners...")

    document.body.addEventListener(
      "click",
      (event) => {
        this.handleClick(event)
      },
      true,
    )

    this.setupMutationObserver()

    this.log("Click tracking setup complete")
  }

  setupMutationObserver() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === 1) {
              const webBtns = node.querySelectorAll ? node.querySelectorAll(".web-btn") : []
              const priceBtns = node.querySelectorAll ? node.querySelectorAll(".prc-btn-new") : []

              if (webBtns.length > 0 || priceBtns.length > 0) {
                this.log(`New buttons detected: ${webBtns.length} web buttons, ${priceBtns.length} price buttons`)
              }
            }
          })
        }
      })
    })

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    })
  }

  handleClick(event) {
    const target = event.target
    const button = target.closest("button")

    if (!button) return

    this.log("Button clicked:", button)

    let buttonType = null
    let isTrackedButton = false

    if (button.classList.contains("web-btn")) {
      buttonType = "website"
      isTrackedButton = true
      this.log("Website button detected")
    } else if (button.classList.contains("prc-btn-new")) {
      buttonType = "price"
      isTrackedButton = true
      this.log("Price button detected")
    }

    if (isTrackedButton) {
      this.handleButtonClick(button, buttonType, event)
    }
  }

  handleButtonClick(button, buttonType, event) {
    this.log(`Handling ${buttonType} button click`)

    const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
    if (!card) {
      this.log("No parent card found")
      return
    }

    this.log("Parent card found:", card)

    const itemName = this.getItemName(card)
    if (!itemName) {
      this.log("Could not extract item name")
      return
    }

    this.log(`Extracted item name: "${itemName}"`)

    this.trackClick(itemName, buttonType)

    this.showClickFeedback(button, itemName, buttonType)
  }

  getItemName(card) {
    this.log("Extracting item name from card:", card)

    let itemName = card.getAttribute("data-name")
    if (itemName) {
      this.log(`Found item name from data-name: "${itemName}"`)
      return itemName
    }

    const titleElement = card.querySelector(".crd-ttl") || card.querySelector(".lst-itm-ttl")
    if (titleElement) {
      const fullText = titleElement.textContent || titleElement.innerText || ""
      itemName = fullText
        .replace(/Verified|Premium|Warning|Updated|Down|Unknown|Untracked/g, "")
        .replace(/\s+/g, " ")
        .trim()

      this.log(`Found item name from title element: "${itemName}"`)
      return itemName
    }

    const cardText = card.textContent || card.innerText || ""
    for (const exploit of expData) {
      if (cardText.includes(exploit.name)) {
        this.log(`Found item name by matching card content: "${exploit.name}"`)
        return exploit.name
      }
    }

    this.log("Could not extract item name from card")
    return null
  }

  async
  trackClick(itemName, buttonType) {
    return window.apiClient.trackClick(itemName, buttonType)
  }

  showClickFeedback(button, itemName, buttonType) {
    const feedback = document.createElement("div")

    document.body.appendChild(feedback)

    setTimeout(() => {
      feedback.style.opacity = "1"
    }, 10)

    setTimeout(() => {
      feedback.style.opacity = "0"
      setTimeout(() => {
        if (feedback.parentNode) {
          feedback.parentNode.removeChild(feedback)
        }
      }, 300)
    }, 2000)
  }

  queueFailedClick(itemName, buttonType) {
    this.log(`Queueing failed click: ${buttonType} for "${itemName}"`)

    try {
      const failedClicks = JSON.parse(localStorage.getItem("failed_clicks") || "[]")
      failedClicks.push({
        item: itemName,
        button_type: buttonType,
        timestamp: Date.now(),
      })
      localStorage.setItem("failed_clicks", JSON.stringify(failedClicks))
      this.log(`Queued failed click. Total queued: ${failedClicks.length}`)
    } catch (error) {
      this.log("Error queueing failed click:", error)
    }
  }

  async
  retryFailedClicks() {
    this.log("Attempting to retry failed clicks...")

    try {
      const failedClicks = JSON.parse(localStorage.getItem("failed_clicks") || "[]")
      if (failedClicks.length === 0) {
        this.log("No failed clicks to retry")
        return
      }

      this.log(`Retrying ${failedClicks.length} failed clicks`)

      const retryPromises = failedClicks.map((click) => this.trackClick(click.item, click.button_type))

      Promise.allSettled(retryPromises)
      localStorage.removeItem("failed_clicks")
      this.log("✅ Finished retrying failed clicks")
    } catch (error) {
      this.log("❌ Error retrying failed clicks:", error)
    }
  }

  testTracking() {
    this.log("Testing click tracking...")
    this.trackClick("Test Exploit", "website")
    this.trackClick("Test Exploit", "price")
  }
}

const themeSettings = {
  primaryColor: "#ff0000",
  _p3: "dm94bGlz",
  secondaryColor: "#00ff00",
  animations: true,
}

class PerformanceMonitor {
  constructor() {
    this.fps = 0
    this.frameCount = 0
    this.lastTime = performance.now()
    this.memoryUsage = 0
    this.deviceTier = "unknown"
    this.isLowEndDevice = false
  }

  start() {
    this.checkDevicePerformance()
    this.monitorFPS()
    return this
  }

  monitorFPS() {
    const updateFPS = () => {
      const now = performance.now()
      const elapsed = now - this.lastTime

      if (elapsed >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / elapsed)
        this.frameCount = 0
        this.lastTime = now

        if (typeof performance.memory !== "undefined") {
          this.memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024)
        }
      }

      this.frameCount++
      requestAnimationFrame(updateFPS)
    }

    requestAnimationFrame(updateFPS)
  }

  checkDevicePerformance() {
    const memoryScore = this.getMemoryScore()
    const cpuScore = this.getCPUScore()

    const totalScore = cpuScore * 0.7 + memoryScore * 0.3

    if (totalScore < 30) {
      this.deviceTier = "low"
      this.isLowEndDevice = true
    } else if (totalScore < 60) {
      this.deviceTier = "medium"
      this.isLowEndDevice = false
    } else {
      this.deviceTier = "high"
      this.isLowEndDevice = false
    }

    return this.deviceTier
  }

  getCPUScore() {
    const samples = 3
    let totalIterations = 0

    for (let sample = 0; sample < samples; sample++) {
      const startTime = performance.now()
      let iterations = 0

      while (performance.now() - startTime < 100) {
        for (let i = 0; i < 5000; i++) {
          Math.sqrt(Math.random() * 10000)
          Math.sin(Math.random() * Math.PI)
          Math.cos(Math.random() * Math.PI)
        }
        iterations++
      }

      totalIterations += iterations
    }

    const avgIterations = totalIterations / samples
    return Math.min(100, avgIterations * 4)
  }

  getMemoryScore() {
    let memoryScore = 50

    if (typeof navigator.deviceMemory !== "undefined") {
      memoryScore = Math.min(100, navigator.deviceMemory * 12.5)
    } else if (typeof performance.memory !== "undefined") {
      const totalJSHeapSize = performance.memory.jsHeapSizeLimit / (1024 * 1024)
      memoryScore = Math.min(100, totalJSHeapSize / 20)
    }

    return memoryScore
  }
}

const debugSettings = {
  logLevel: "info",
  enableConsole: true,
  _p4: "Lm5ldC9jb3VudHMucGhw",
  showErrors: true,
}

class LazyLoader {
  constructor() {
    this.observer = null
    this.initialized = false
  }

  init() {
    if ("IntersectionObserver" in window) {
      this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
        rootMargin: "200px",
        threshold: 0.1,
      })
      this.initialized = true
    }
    return this
  }

  observe(elements) {
    if (!this.initialized) return

    if (elements instanceof NodeList || Array.isArray(elements)) {
      elements.forEach((el) => this.observer.observe(el))
    } else if (elements instanceof Element) {
      this.observer.observe(elements)
    }
  }

  onIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const element = entry.target

        if (element.dataset.lazySrc) {
          element.src = element.dataset.lazySrc
          delete element.dataset.lazySrc
        }

        if (element.dataset.lazyBg) {
          element.style.backgroundImage = `url(${element.dataset.lazyBg})`
          delete element.dataset.lazyBg
        }

        if (element.classList.contains("lazy-load")) {
          element.classList.add("loaded")
          element.classList.remove("lazy-load")
        }

        this.observer.unobserve(element)
      }
    })
  }
}

class PaginationManager {
  constructor(containerSelector, itemCreator, dataSource, options = {}) {
    this.container = document.querySelector(containerSelector)
    this.itemCreator = itemCreator
    this.dataSource = dataSource
    this.options = {
      itemsPerPage: options.itemsPerPage || 9,
      ...options,
    }

    this.currentPage = 1
    this.totalPages = 1
    this.renderedItems = new Map()
    this.initialized = false

    this.paginationContainer = document.getElementById("paginationContainer")
    this.prevBtn = document.getElementById("prevPageBtn")
    this.nextBtn = document.getElementById("nextPageBtn")
    this.pageNumbers = document.getElementById("pageNumbers")
    this.paginationInfo = document.getElementById("paginationInfo")
    this.pageInfo = document.getElementById("pageInfo")
  }

  init() {
    if (!this.container) return this

    this.setupPaginationControls()
    this.render()
    this.initialized = true

    return this
  }

  setupPaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.addEventListener("click", () => {
        if (this.currentPage > 1) {
          this.goToPage(this.currentPage - 1)
        }
      })
    }

    if (this.nextBtn) {
      this.nextBtn.addEventListener("click", () => {
        if (this.currentPage < this.totalPages) {
          this.goToPage(this.currentPage + 1)
        }
      })
    }
  }

  updateData(newData) {
    this.dataSource = newData
    this.currentPage = 1
    this.clear()
    this.render()
  }

  calculateTotalPages() {
    return Math.ceil(this.dataSource.length / this.options.itemsPerPage)
  }

  getCurrentPageData() {
    const startIndex = (this.currentPage - 1) * this.options.itemsPerPage
    const endIndex = startIndex + this.options.itemsPerPage
    return this.dataSource.slice(startIndex, endIndex)
  }

  goToPage(pageNumber) {
    if (pageNumber < 1 || pageNumber > this.totalPages) return

    this.currentPage = pageNumber
    this.clear()
    this.render()
  }

  render() {
    this.totalPages = this.calculateTotalPages()

    if (this.totalPages === 0) {
      this.hidePagination()
      return
    }

    this.showPagination()

    const currentPageData = this.getCurrentPageData()
    const fragment = document.createDocumentFragment()

    this.container.innerHTML = ""

    currentPageData.forEach((data, index) => {
      const element = this.itemCreator(data, index)
      if (element) {
        fragment.appendChild(element)
      }
    })

    this.container.appendChild(fragment)
    this.updatePaginationControls()
    this.updatePageInfo()
  }

  updatePaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.disabled = this.currentPage === 1
    }

    if (this.nextBtn) {
      this.nextBtn.disabled = this.currentPage === this.totalPages
    }

    if (this.pageNumbers) {
      this.pageNumbers.innerHTML = ""

      const maxVisiblePages = 5
      let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2))
      const endPage = Math.min(this.totalPages, startPage + maxVisiblePages - 1)

      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1)
      }

      if (startPage > 1) {
        this.addPageButton(1)
        if (startPage > 2) {
          this.addEllipsis()
        }
      }

      for (let i = startPage; i <= endPage; i++) {
        this.addPageButton(i)
      }

      if (endPage < this.totalPages) {
        if (endPage < this.totalPages - 1) {
          this.addEllipsis()
        }
        this.addPageButton(this.totalPages)
      }
    }

    if (this.paginationInfo) {
      this.paginationInfo.textContent = `Page ${this.currentPage} of ${this.totalPages}`
    }
  }

  addPageButton(pageNumber) {
    const button = document.createElement("button")
    button.className = `page-number ${pageNumber === this.currentPage ? "active" : ""}`
    button.textContent = pageNumber
    button.addEventListener("click", () => this.goToPage(pageNumber))
    this.pageNumbers.appendChild(button)
  }

  addEllipsis() {
    const ellipsis = document.createElement("span")
    ellipsis.className = "page-ellipsis"
    ellipsis.textContent = "..."
    this.pageNumbers.appendChild(ellipsis)
  }

  updatePageInfo() {
    if (this.pageInfo) {
      const startItem = (this.currentPage - 1) * this.options.itemsPerPage + 1
      const endItem = Math.min(this.currentPage * this.options.itemsPerPage, this.dataSource.length)
      this.pageInfo.textContent = ` (${startItem}-${endItem})`
    }
  }

  showPagination() {
    if (this.paginationContainer && this.totalPages > 1) {
      this.paginationContainer.style.display = "block"
    }
  }

  hidePagination() {
    if (this.paginationContainer) {
      this.paginationContainer.style.display = "none"
    }
  }

  clear() {
    this.renderedItems.clear()
    if (this.container) {
      this.container.innerHTML = ""
    }
  }
}

class AppState {
  constructor() {
    this.view = "grid"
    this.query = ""
    this.platformFilters = []
    this.levelFilters = [0, 0]
    this.priceFilter = "all"
    this.verifiedOnly = false
    this.premiumOnly = false
    this.externalOnly = false
    this.executorOnly = false
    this.keySystemOnly = false
    this.noKeySystemOnly = false
    this.updatedOnly = false
    this.sortBy = "most-popular"
    this.filteredData = []
    this.performanceMonitor = new PerformanceMonitor().start()
    this.lazyLoader = new LazyLoader().init()
    this.paginationManager = null
    this.isLoading = false
    this.scrollPosition = 0
    this.isFilterDrawerOpen = false
    this.clickTracker = new ClickTracker()
    this.clickDataLoaded = false
    this.exploitStatuses = new Map()
    this.statusLoadTime = 0
  }

  async init() {
    this.clickTracker.init()

    try {
      await fetchClickCounts()
      this.clickDataLoaded = true
    } catch (error) {
      this.clickDataLoaded = false
    }

    try {
      await fetchRobloxVersion()
    } catch (error) {
      console.warn("Failed to fetch Roblox version data:", error)
    }

    const statusStartTime = performance.now()
    await this.updateAllExploitStatuses()
    this.statusLoadTime = performance.now() - statusStartTime

    this.filteredData = expData.filter((exp) => exp.hide !== true)
    this.filterExploits()

    return this
  }

  async updateAllExploitStatuses() {
    try {
      const statusMap = await fetchAllExploitStatuses()

      for (const [exploitId, status] of statusMap) {
        this.exploitStatuses.set(exploitId, status)
      }
    } catch (error) {
      console.warn("Failed to update exploit statuses:", error)

      for (const exploit of expData) {
        this.exploitStatuses.set(exploit.id, "unknown")
      }
    }
  }

  getExploitStatus(exploitId) {
    const rawStatus = this.exploitStatuses.get(exploitId)

    if (rawStatus === "unknown") {
      return "unknown"
    }
    if (typeof rawStatus === "boolean") {
      return rawStatus ? "updated" : "down"
    }
    if (typeof rawStatus === "object" && rawStatus !== null) {
      const hasUpdatedPlatform = Object.values(rawStatus).some((status) => status === true)
      const allPlatformsDown = Object.values(rawStatus).every((status) => status === false)

      if (hasUpdatedPlatform) {
        return "updated"
      } else if (allPlatformsDown && Object.keys(rawStatus).length > 0) {
        return "down"
      }
    }
    return "unknown"
  }

  filterExploits() {
    this.filteredData = expData
      .filter((exp) => {
        if (exp.hide === true) return false

        if (this.query) {
          const query = this.query.toLowerCase()
          const nameMatch = exp.name.toLowerCase().includes(query)
          const descMatch = exp.desc.toLowerCase().includes(query)
          const platformMatch = exp.plat && exp.plat.some((platform) => platform.toLowerCase().includes(query))
          const uncMatch =
            exp.pros && exp.pros.some((pro) => pro.toLowerCase().includes("unc") && pro.toLowerCase().includes(query))
          const uncNeutralMatch =
            exp.neutral &&
            exp.neutral.some(
              (neutral) => neutral.toLowerCase().includes("unc") && neutral.toLowerCase().includes(query),
            )

          if (!(nameMatch || descMatch || platformMatch || uncMatch || uncNeutralMatch)) {
            return false
          }
        }

        if (this.platformFilters.length > 0) {
          if (!this.platformFilters.some((platform) => exp.plat.includes(platform))) {
            return false
          }
        }

        if (this.levelFilters[1] !== 0) {
          if (exp.external === true) {
            return false
          } else if (typeof exp.lvl === "undefined" || exp.lvl !== this.levelFilters[1]) {
            return false
          }
        }

        if (this.priceFilter !== "all") {
          if (this.priceFilter === "free" && exp.price !== "FREE" && !exp.free) {
            return false
          }
          if (this.priceFilter === "paid" && (exp.price === "FREE" || exp.free)) {
            return false
          }
        }

        if (this.verifiedOnly && !exp.verified) {
          return false
        }

        if (this.premiumOnly && !exp.premium) {
          return false
        }

        if (this.externalOnly && exp.external !== true) {
          return false
        }

        if (this.executorOnly) {
          let isConsideredExternal = exp.external === true
          if (typeof exp.external === "undefined") {
            isConsideredExternal =
              (exp.pros && exp.pros.some((pro) => pro.toLowerCase().includes("external"))) ||
              (exp.neutral && exp.neutral.some((neutral) => neutral.toLowerCase().includes("external")))
          }
          if (isConsideredExternal) {
            return false
          }
        }

        if (this.keySystemOnly && !exp.hasKeySystem) {
          return false
        }

        if (this.noKeySystemOnly) {
          if (exp.hasKeySystem) {
            return false
          }
          if (exp.price !== "FREE" && !exp.free) {
            return false
          }
        }

        if (this.updatedOnly) {
          const status = this.getExploitStatus(exp.id)
          if (status !== "updated") {
            return false
          }
        }

        return true
      })
      .sort((a, b) => {
        if (a.premium && !b.premium) return -1
        if (!a.premium && b.premium) return 1

        switch (this.sortBy) {
          case "recommended":
            return 0
          case "most-popular":
            const clicksA = getTotalClicks(a.name)
            const clicksB = getTotalClicks(b.name)
            if (this.clickDataLoaded && clicksA !== clicksB) {
              return clicksB - clicksA
            }
            return a.name.localeCompare(b.name)
          case "least-popular":
            return getTotalClicks(a.name) - getTotalClicks(b.name)
          case "price-asc":
            const priceA = this.extractPrice(a.price)
            const priceB = this.extractPrice(b.price)
            return priceA - priceB
          case "price-desc":
            const priceDescA = this.extractPrice(a.price)
            const priceDescB = this.extractPrice(b.price)
            return priceDescB - priceDescA
          case "level-desc":
            const levelA = a.lvl || 0
            const levelB = b.lvl || 0
            return levelB - levelA
          case "name-asc":
            return a.name.localeCompare(b.name)
          default:
            return 0
        }
      })

    return this.filteredData
  }

  extractPrice(price) {
    if (price === "FREE") return 0
    const numericPrice = Number.parseFloat(price.replace(/[^\d.]/g, ""))
    return isNaN(numericPrice) ? 0 : numericPrice
  }

  comparePrices(a, b) {
    const getPriceValue = (price) => {
      if (Array.isArray(price)) {
        return Number.parseFloat(price[0].replace(/[^\d.]/g, "")) || 0
      }
      return price === "FREE" ? 0 : Number.parseFloat(price.replace(/[^\d.]/g, "")) || 0
    }

    return getPriceValue(a.price) - getPriceValue(b.price)
  }

  saveScrollPosition() {
    this.scrollPosition = window.pageYOffset || document.documentElement.scrollTop
  }

  restoreScrollPosition() {
    if (this.scrollPosition > 0) {
      window.scrollTo(0, this.scrollPosition)
    }
  }
}

class UIManager {
  constructor(appState) {
    this.appState = appState
    this.elements = {}
    this.debounceTimers = {}
    this.isUpdating = false
  }

  init() {
    this.initElements()
    this.setupEventListeners()
    this.updateCounts()
    this.initPaginationManager()
    this.createModals()
    this.setupDropdowns()
    this.initTextSwitching()
    this.updateScrollbarStyles()
    this.handleWindowResize()

    const levelVal = this.getElement("levelValue")
    const mobileLevelVal = this.getElement("mobileLevelValue")
    if (levelVal) levelVal.textContent = "ALL"
    if (mobileLevelVal) mobileLevelVal.textContent = "ALL"

    this.setDefaultSortOption()

    window.uiManager = this

    return this
  }

  setDefaultSortOption() {
    const sortSelect = this.getElement("sortSelect")
    const mobileSortSelect = this.getElement("mobileSortSelect")

    if (sortSelect) {
      sortSelect.value = "most-popular"
    }
    if (mobileSortSelect) {
      mobileSortSelect.value = "most-popular"
    }

    const dropdownOptions = document.querySelectorAll('.custom-dropdown-option[data-value="most-popular"]')
    dropdownOptions.forEach((option) => {
      const dropdown = option.closest(".custom-dropdown")
      if (dropdown) {
        const selected = dropdown.querySelector(".custom-dropdown-selected span")
        if (selected) {
          selected.textContent = "Most Popular"
        }
        dropdown.querySelectorAll(".custom-dropdown-option").forEach((opt) => opt.classList.remove("selected"))
        option.classList.add("selected")
      }
    })
  }

  initElements() {
    const selectors = {
      header: "#hdr",
      hero: "#heroSec",
      menuToggle: "#mobMenuTgl",
      menu: "#mobMenu",
      search: "#srchInp",
      mobileSearch: "#mobSrchInp",
      clearButton: "#clrSrch",
      mobileClearButton: "#mobClrSrch",
      filterButton: "#fltrBtn",
      mobileFilterButton: "#mobFltrBtn",
      drawer: "#fltrDrwr",
      applyButton: "#applyFltrs",
      closeButton: "#fasfa-times",
      levelSlider: "#lvlSldr",
      mobileLevelSlider: "#mobLvlSldr",
      levelValue: "#lvlMaxVal",
      mobileLevelValue: "#mobLvlMaxVal",
      levelFill: "#lvlTrkFill",
      mobileLevelFill: "#mobLvlTrkFill",
      verifiedSwitch: "#vrfSwch",
      mobileVerifiedSwitch: "#mobVrfSwch",
      premiumSwitch: "#premSwch",
      mobilePremiumSwitch: "#mobPremSwch",
      externalSwitch: "#extSwch",
      mobileExternalSwitch: "#mobExtSwch",
      executorSwitch: "#execSwch",
      mobileExecutorSwitch: "#mobExecSwch",
      keySwitch: "#keySwch",
      mobileKeySwitch: "#mobKeySwch",
      noKeySwitch: "#noKeySwch",
      mobileNoKeySwitch: "#mobNoKeySwch",
      updatedSwitch: "#updatedSwch",
      mobileUpdatedSwitch: "#mobUpdatedSwch",
      sortSelect: "#srtSel",
      mobileSortSelect: "#mobSortSel",
      resetButton: "#rstFltrs",
      mobileResetButton: "#mobRstFltrs",
      resetAllButton: "#rstAllFltrs",
      grid: "#expsGrid",
      list: "#expsList",
      noResults: "#noRes",
      filteredCount: "#fltrdCnt",
      totalCount: "#ttlCnt",
      tabButtons: ".tab-trgr",
      tabContent: ".tab-cntnt",
      canvas: "#strCnv",
      loadingScreen: "#loadingScreen",
      loadingBar: "#loadingBar",
      logoTextGradient: ".logo-txt-grd",
      logoTextLight: ".logo-txt-lt",
      themeDropdown: "#themeDropdown",
      themeDropdownSelected: "#themeDropdownSelected",
      themeDropdownOptions: "#themeDropdownOptions",
    }

    for (const [key, selector] of Object.entries(selectors)) {
      if (selector.startsWith(".")) {
        this.elements[key] = document.querySelectorAll(selector)
      } else {
        this.elements[key] = document.getElementById(selector.substring(1))
      }
    }
  }

  getElement(key) {
    return this.elements[key]
  }

  debounce(func, wait, key) {
    return (...args) => {
      clearTimeout(this.debounceTimers[key])
      this.debounceTimers[key] = setTimeout(() => func.apply(this, args), wait)
    }
  }

  setupEventListeners() {
    window.addEventListener("scroll", () => {
      const heroHeight = this.getElement("hero") ? this.getElement("hero").offsetHeight : 0
      if (window.scrollY > 0) {
        this.getElement("header").classList.add("scrolled")
      } else {
        this.getElement("header").classList.remove("scrolled")
      }
    })

    this.setupSearchListeners()
    this.setupFilterDrawer()
    this.setupLevelSliders()
    this.setupPlatformFilters()
    this.setupPriceFilters()
    this.setupToggleSwitches()
    this.setupSortSelects()
    this.setupResetButtons()
    this.setupTabButtons()

    window.addEventListener("resize", this.debounce(this.handleWindowResize.bind(this), 100, "resize"))
  }

  setupSearchListeners() {
    const search = this.getElement("search")
    const mobileSearch = this.getElement("mobileSearch")
    const clearButton = this.getElement("clearButton")
    const mobileClearButton = this.getElement("mobileClearButton")

    const handleSearchInput = this.debounce(
      (e) => {
        this.appState.query = e.target.value
        if (mobileSearch && e.target !== mobileSearch) mobileSearch.value = this.appState.query
        if (search && e.target !== search) search.value = this.appState.query
        if (clearButton) clearButton.classList.toggle("hidden", !this.appState.query)
        if (mobileClearButton) mobileClearButton.classList.toggle("hidden", !this.appState.query)
        this.updateExploits()
      },
      200,
      "search",
    )

    if (search) {
      search.addEventListener("input", handleSearchInput)
    }

    if (mobileSearch) {
      mobileSearch.addEventListener("input", handleSearchInput)
    }

    const clearSearch = () => {
      this.appState.query = ""
      if (search) search.value = ""
      if (mobileSearch) mobileSearch.value = ""
      if (clearButton) clearButton.classList.add("hidden")
      if (mobileClearButton) mobileClearButton.classList.add("hidden")
      this.updateExploits()
    }

    if (clearButton) {
      clearButton.addEventListener("click", clearSearch)
    }

    if (mobileClearButton) {
      mobileClearButton.addEventListener("click", clearSearch)
    }
  }

  setupFilterDrawer() {
    const filterButton = this.getElement("filterButton")
    const mobileFilterButton = this.getElement("mobileFilterButton")
    const drawer = this.getElement("drawer")
    const applyButton = this.getElement("applyButton")
    const closeButton = this.getElement("closeButton")

    const openDrawer = () => {
      this.appState.saveScrollPosition()
      this.appState.isFilterDrawerOpen = true
      drawer.classList.add("open")
      document.body.style.overflow = "hidden"
      document.body.style.position = "fixed"
      document.body.style.top = `-${this.appState.scrollPosition}px`
      document.body.style.width = "100%"
    }

    const closeDrawer = () => {
      this.appState.isFilterDrawerOpen = false
      drawer.classList.remove("open")
      document.body.style.overflow = ""
      document.body.style.position = ""
      document.body.style.top = ""
      document.body.style.width = ""

      setTimeout(() => {
        this.appState.restoreScrollPosition()
      }, 10)
    }

    if (filterButton && drawer) {
      filterButton.addEventListener("click", openDrawer)
    }

    if (mobileFilterButton && drawer) {
      mobileFilterButton.addEventListener("click", () => {
        openDrawer()
        const menu = this.getElement("menu")
        
        if (menu) menu.classList.add("hidden")
        document.body.classList.remove("menu-open")
      })
    }

    if (drawer) {
      const overlay = drawer.querySelector(".fltr-drwr-ovl")
      if (overlay) {
        overlay.addEventListener("click", closeDrawer)
      }
    }

    if (applyButton && drawer) {
      applyButton.addEventListener("click", closeDrawer)
    }

    if (closeButton && drawer) {
      closeButton.addEventListener("click", closeDrawer)
    }
  }

  setupLevelSliders() {
    const levelSlider = this.getElement("levelSlider")
    const mobileLevelSlider = this.getElement("mobileLevelSlider")

    const updateLevelSlider = (slider, value, isMobile) => {
      const levelVal = isMobile ? this.getElement("mobileLevelValue") : this.getElement("levelValue")
      const otherSlider = isMobile ? this.getElement("levelSlider") : this.getElement("mobileLevelSlider")
      const otherLevelVal = isMobile ? this.getElement("levelValue") : this.getElement("mobileLevelValue")
      const levelFill = isMobile ? this.getElement("mobileLevelFill") : this.getElement("levelFill")

      this.appState.levelFilters = [0, value]

      if (levelVal) levelVal.textContent = value === 0 ? "ALL" : value
      if (otherSlider) otherSlider.value = value
      if (otherLevelVal) otherLevelVal.textContent = value === 0 ? "ALL" : value

      if (levelFill) {
        const percent = (value / slider.max) * 100
        levelFill.style.width = `${percent}%`
      }

      this.updateExploits()
    }

    if (levelSlider) {
      levelSlider.addEventListener(
        "input",
        this.debounce(
          (e) => {
            updateLevelSlider(e.target, Number.parseInt(e.target.value), false)
          },
          100,
          "levelSlider",
        ),
      )
    }

    if (mobileLevelSlider) {
      mobileLevelSlider.addEventListener(
        "input",
        this.debounce(
          (e) => {
            updateLevelSlider(e.target, Number.parseInt(e.target.value), true)
          },
          100,
          "mobileLevelSlider",
        ),
      )
    }
  }

  setupPlatformFilters() {
    document.querySelectorAll(".cstm-chkbx input[data-pltf], .mob-pltf-chkbx input[data-pltf]").forEach((checkbox) => {
      checkbox.addEventListener("change", () => {
        const platform = checkbox.getAttribute("data-pltf")

        if (checkbox.checked) {
          if (!this.appState.platformFilters.includes(platform)) {
            this.appState.platformFilters.push(platform)
          }
        } else {
          this.appState.platformFilters = this.appState.platformFilters.filter((p) => p !== platform)
        }

        document.querySelectorAll(`[data-pltf="${platform}"]`).forEach((cb) => {
          cb.checked = checkbox.checked
        })

        this.updateExploits()
      })
    })
  }

  setupPriceFilters() {
    document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((button) => {
      button.addEventListener("click", () => {
        const price = button.getAttribute("data-prc")
        this.appState.priceFilter = price

        document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
          btn.classList.remove("actv")
          if (btn.getAttribute("data-prc") === price) {
            btn.classList.add("actv")
          }
        })

        this.updateExploits()
      })
    })
  }

  setupToggleSwitches() {
    const setupSwitchPair = (mainSwitch, mobileSwitch, stateProperty) => {
      if (mainSwitch) {
        mainSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mainSwitch.checked
          if (mobileSwitch) mobileSwitch.checked = mainSwitch.checked

          if (stateProperty === "keySystemOnly" && mainSwitch.checked) {
            const noKeySwitch = this.getElement("noKeySwitch")
            if (noKeySwitch && noKeySwitch.checked) {
              noKeySwitch.checked = false
              this.appState.noKeySystemOnly = false
              const mobileNoKeySwitch = this.getElement("mobileNoKeySwitch")
              if (mobileNoKeySwitch) mobileNoKeySwitch.checked = false
            }
          } else if (stateProperty === "noKeySystemOnly" && mainSwitch.checked) {
            const keySwitch = this.getElement("keySwitch")
            if (keySwitch && keySwitch.checked) {
              keySwitch.checked = false
              this.appState.keySystemOnly = false
              const mobileKeySwitch = this.getElement("mobileKeySwitch")
              if (mobileKeySwitch) mobileKeySwitch.checked = false
            }
          }

          this.updateExploits()
        })
      }

      if (mobileSwitch) {
        mobileSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mobileSwitch.checked
          if (mainSwitch) mainSwitch.checked = mobileSwitch.checked

          if (stateProperty === "keySystemOnly" && mobileSwitch.checked) {
            const mobileNoKeySwitch = this.getElement("mobileNoKeySwitch")
            if (mobileNoKeySwitch && mobileNoKeySwitch.checked) {
              mobileNoKeySwitch.checked = false
              this.appState.noKeySystemOnly = false
              const noKeySwitch = this.getElement("noKeySwitch")
              if (noKeySwitch) noKeySwitch.checked = false
            }
          } else if (stateProperty === "noKeySystemOnly" && mobileSwitch.checked) {
            const mobileKeySwitch = this.getElement("mobileKeySwitch")
            if (mobileKeySwitch && mobileKeySwitch.checked) {
              mobileKeySwitch.checked = false
              this.appState.keySystemOnly = false
              const keySwitch = this.getElement("keySwitch")
              if (keySwitch) keySwitch.checked = false
            }
          }

          this.updateExploits()
        })
      }
    }

    setupSwitchPair(this.getElement("verifiedSwitch"), this.getElement("mobileVerifiedSwitch"), "verifiedOnly")
    setupSwitchPair(this.getElement("premiumSwitch"), this.getElement("mobilePremiumSwitch"), "premiumOnly")
    setupSwitchPair(this.getElement("externalSwitch"), this.getElement("mobileExternalSwitch"), "externalOnly")
    setupSwitchPair(this.getElement("executorSwitch"), this.getElement("mobileExecutorSwitch"), "executorOnly")
    setupSwitchPair(this.getElement("keySwitch"), this.getElement("mobileKeySwitch"), "keySystemOnly")
    setupSwitchPair(this.getElement("noKeySwitch"), this.getElement("mobileNoKeySwitch"), "noKeySystemOnly")
    setupSwitchPair(this.getElement("updatedSwitch"), this.getElement("mobileUpdatedSwitch"), "updatedOnly")
  }

  setupSortSelects() {
    const sortSelect = this.getElement("sortSelect")
    const mobileSortSelect = this.getElement("mobileSortSelect")

    if (sortSelect) {
      sortSelect.addEventListener("change", () => {
        this.appState.sortBy = sortSelect.value
        if (mobileSortSelect) mobileSortSelect.value = this.appState.sortBy
        this.updateExploits()
      })
    }

    if (mobileSortSelect) {
      mobileSortSelect.addEventListener("change", () => {
        this.appState.sortBy = mobileSortSelect.value
        if (sortSelect) sortSelect.value = this.appState.sortBy
        this.updateExploits()
      })
    }
  }

  setupResetButtons() {
    const resetFilters = () => {
      this.appState.platformFilters = []
      this.appState.levelFilters = [0, 0]
      this.appState.priceFilter = "all"
      this.appState.verifiedOnly = false
      this.appState.premiumOnly = false
      this.appState.externalOnly = false
      this.appState.executorOnly = false
      this.appState.keySystemOnly = false
      this.appState.noKeySystemOnly = false
      this.appState.updatedOnly = false

      document.querySelectorAll(".cstm-chkbx input, .mob-pltf-chkbx input").forEach((cb) => {
        cb.checked = false
      })

      document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
        btn.classList.remove("actv")
        if (btn.getAttribute("data-prc") === "all") {
          btn.classList.add("actv")
        }
      })

      const levelSlider = this.getElement("levelSlider")
      const mobileLevelSlider = this.getElement("mobileLevelSlider")
      const levelVal = this.getElement("levelValue")
      const mobileLevelVal = this.getElement("mobileLevelValue")

      if (levelSlider) levelSlider.value = 0
      if (mobileLevelSlider) mobileLevelSlider.value = 0
      if (levelVal) levelVal.textContent = "ALL"
      if (mobileLevelVal) mobileLevelVal.textContent = "ALL"

      const levelFill = this.getElement("levelFill")
      const mobileLevelFill = this.getElement("mobileLevelFill")
      if (levelFill) levelFill.style.width = "0%"
      if (mobileLevelFill) mobileLevelFill.style.width = "0%"

      const switches = [
        "verifiedSwitch",
        "mobileVerifiedSwitch",
        "premiumSwitch",
        "mobilePremiumSwitch",
        "externalSwitch",
        "mobileExternalSwitch",
        "executorSwitch",
        "mobileExecutorSwitch",
        "keySwitch",
        "mobileKeySwitch",
        "noKeySwitch",
        "mobileNoKeySwitch",
        "updatedSwitch",
        "mobileUpdatedSwitch",
      ]

      switches.forEach((switchKey) => {
        const switchElement = this.getElement(switchKey)
        if (switchElement) switchElement.checked = false
      })

      this.updateExploits()
    }

    const resetButtons = [
      this.getElement("resetButton"),
      this.getElement("mobileResetButton"),
      this.getElement("resetAllButton"),
    ]

    resetButtons.forEach((button) => {
      if (button) {
        button.addEventListener("click", resetFilters)
      }
    })
  }

  setupTabButtons() {
    const tabButtons = this.getElement("tabButtons")
    const tabContent = this.getElement("tabContent")

    if (tabButtons && tabButtons.length) {
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.getAttribute("data-tab")
          this.appState.view = tab

          tabButtons.forEach((btn) => btn.classList.remove("actv"))
          button.classList.add("actv")

          if (tabContent && tabContent.length) {
            tabContent.forEach((content) => content.classList.remove("actv"))
            const activeContent = document.getElementById(`${tab}Tab`)
            if (activeContent) activeContent.classList.add("actv")
          }

          this.updateExploits()
        })
      })
    }
  }

  initPaginationManager() {
    const grid = this.getElement("grid")

    if (grid) {
      this.appState.paginationManager = new PaginationManager(
        "#expsGrid",
        this.createCard.bind(this),
        this.appState.filteredData,
        {
          itemsPerPage: 9,
        },
      ).init()
    }
  }

  updateExploits() {
    if (this.isUpdating) return
    this.isUpdating = true

    requestAnimationFrame(() => {
      try {
        const filteredData = this.appState.filterExploits()
        const noResults = this.getElement("noResults")

        if (filteredData.length === 0) {
          if (noResults) noResults.classList.remove("hidden")
        } else {
          if (noResults) noResults.classList.add("hidden")
        }

        if (this.appState.paginationManager && this.appState.view === "grid") {
          this.appState.paginationManager.updateData(filteredData)
        }

        this.updateCounts()

        setTimeout(() => {
          this.setupCardButtons()
          this.isUpdating = false
        }, 50)
      } catch (error) {
        console.error("Error updating exploits:", error)
        this.isUpdating = false
      }
    })
  }

  createCard(exploit) {
    const card = document.createElement("div")
    card.className = "exp-crd"
    if (exploit.premium) card.classList.add("prem")

    card.setAttribute("data-id", exploit.id)
    card.setAttribute("data-name", exploit.name)

    const accentColor = exploit.premium ? "prem" : exploit.accentColor
    let levelDisplay = ""
    if (exploit.external === true) {
      levelDisplay = `<div class="lvl-bdg ${exploit.txtColor}">External</div>`
    } else if (typeof exploit.lvl !== "undefined") {
      levelDisplay = `<div class="lvl-bdg ${exploit.txtColor}">Level ${exploit.lvl}</div>`
    }

    const status = this.appState.getExploitStatus(exploit.id)
    let statusClass = "untracked"
    switch (status) {
      case "updated":
        statusClass = "updated"
        break
      case "down":
        statusClass = "down"
        break
      case "unknown":
        statusClass = "unknown"
        break
    }
    card.classList.add(`status-${statusClass}`)

    card.innerHTML = `
<div class="crd-acnt ${accentColor}"></div>
<div class="crd-hdr">
<div class="crd-hdr-cntnt">
  <div class="crd-ttl-cntr">
    <h3 class="crd-ttl">
      ${exploit.name}
      ${exploit.verified ? `<span class="vrf-bdg"><i class="fas fa-check"></i>Verified</span>` : ""}
      ${exploit.premium ? `<span class="prem-bdg"><i class="fas fa-crown"></i>Premium</span>` : ""}
      ${exploit.warning ? `<span class="warn-bdg"><i class="fas fa-exclamation-triangle"></i>Warning</span>` : ""}
    </h3>
    <p class="crd-desc">${exploit.desc}</p>
  </div>
  <div class="pltf-bdgs">
    ${this.renderPlatformBadges(exploit)}
  </div>
</div>
</div>
<div class="crd-bdy">
<div class="crd-meta">
  ${levelDisplay}
  <div class="meta-sep"></div>
  <div class="edr-info">Last edited by ${exploit.editor}</div>
</div>
<div class="crd-cntnt cstm-scrlbr">
  ${this.renderFeatureSection(exploit.pros, "pros", "+")}
  ${this.renderFeatureSection(exploit.neutral, "ntrl", "•")}
  ${this.renderFeatureSection(exploit.cons, "cons", "-")}
</div>
</div>
<div class="crd-ftr">
${this.renderCardFooter(exploit)}
</div>
`

    return card
  }

  renderPlatformBadges(exploit) {
    let badges = ""
    const statuses = this.appState.exploitStatuses.get(exploit.id) || {}

    const getStatusInfo = (platform) => {
      let status = "untracked"
      if (typeof statuses === "object" && statuses !== null && statuses.hasOwnProperty(platform)) {
        status = statuses[platform] ? "updated" : "down"
      } else if (statuses === true) {
        status = "updated"
      } else if (statuses === false) {
        status = "down"
      } else if (statuses === "unknown") {
        status = "unknown"
      }
      const statusText = status.charAt(0).toUpperCase() + status.slice(1)
      return {
        className: `status-${status}`,
        text: statusText,
      }
    }

    const uniquePlatforms = [...new Set(exploit.plat)]

    uniquePlatforms.forEach((platform) => {
      const statusInfo = getStatusInfo(platform)
      let iconHtml = ""
      let platformName = ""

      switch (platform) {
        case "windows":
          iconHtml = `<i class="fab fa-windows"></i>`
          platformName = "Windows"
          break
        case "macos":
          iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:16px; height:16px; vertical-align:middle;">`
          platformName = "macos"
          break

        case "android":
          iconHtml = `<i class="fab fa-android"></i>`
          platformName = "Android"
          break
        case "ios":
          iconHtml = `<i class="fab fa-apple"></i>`
          platformName = "iOS"
          break
      }
      if (iconHtml) {
        const tooltipText = `${platformName} | ${statusInfo.text}`
        badges += `
          <div class="pltf-bdg ${statusInfo.className}">
              ${iconHtml}
              <span class="platform-tooltip">${tooltipText}</span>
          </div>`
      }
    })

    if (exploit.hasKeySystem) {
      badges += `
        <div class="pltf-bdg key-system">
            <i class="fas fa-key"></i>
            <span class="platform-tooltip">Has Key System</span>
        </div>`
    }

    return badges
  }

  renderFeatureSection(features, className, icon) {
    if (!features || features.length === 0) return ""

    return `
<div class="feat-sec ${className}">
<h4 class="feat-hdng">
  <span class="feat-ico">${icon}</span>
  ${className === "pros" ? "Pros" : className === "ntrl" ? "Neutral" : "Cons"}
</h4>
<ul class="feat-lst">
  ${features.map((feature) => `<li class="feat-itm">${feature}</li>`).join("")}
</ul>
</div>
`
  }

  renderCardFooter(exploit) {
    const websiteButtonText = exploit.websitetext || (exploit.websitetofree ? "Free" : "Website")

    if (exploit.price === "FREE") {
      if (exploit.hideunc === true) {
        return `
      <div class="btn-grid free-program-grid">
        <button class="crd-btn info-btn full-width">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${(() => {
        let displayDomain = websiteButtonText
        if (exploit.href) {
          try {
            const url = new URL(exploit.href)
            displayDomain = url.hostname.replace(/^www\./, '')
          } catch (e) {
            displayDomain = exploit.href.replace(/^https?:\/\/(www\.)?/, '').split('/')[0]
          }
        }
        return `<button class="crd-btn web-btn full-width">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`
      })()}
    `
      } else {
        return `
      <div class="btn-grid free-program-grid">
      <button class="crd-btn unc-btn expanded">
        UNC <i class="fas fa-code"></i>
      </button>
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${(() => {
        let displayDomain = websiteButtonText
        if (exploit.href) {
          try {
            const url = new URL(exploit.href)
            displayDomain = url.hostname.replace(/^www\./, '')
          } catch (e) {
            displayDomain = exploit.href.replace(/^https?:\/\/(www\.)?/, '').split('/')[0]
          }
        }
        return `<button class="crd-btn web-btn full-width">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`
      })()}
    `
      }
    } else {
      const baseClasses = ["crd-btn", "prc-btn-new"]
      const finalPriceButtonClasses = baseClasses.join(" ")

      if (exploit.hideunc === true) {
        return `
      <div class="btn-grid">
      ${(() => {
        let displayDomain = websiteButtonText
        if (exploit.href) {
          try {
            const url = new URL(exploit.href)
            displayDomain = url.hostname.replace(/^www\./, '')
          } catch (e) {
            displayDomain = exploit.href.replace(/^https?:\/\/(www\.)?/, '').split('/')[0]
          }
        }
        return `<button class="crd-btn web-btn expanded">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`
      })()}
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      <button class="${finalPriceButtonClasses}">
        <div class="default-text">
          <i class="fas fa-tag"></i> BUY
        </div>
        <div class="price-text">
          <i class="fas fa-tag"></i> ${exploit.price} ${exploit.period ? `<span class="prc-prd">${exploit.period}</span>` : ""}
        </div>
      </button>
    `
      } else {
        return `
      <div class="btn-grid">
      ${(() => {
        let displayDomain = websiteButtonText
        if (exploit.href) {
          try {
            const url = new URL(exploit.href)
            displayDomain = url.hostname.replace(/^www\./, '')
          } catch (e) {
            displayDomain = exploit.href.replace(/^https?:\/\/(www\.)?/, '').split('/')[0]
          }
        }
        return `<button class="crd-btn web-btn expanded">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`
      })()}
        <button class="crd-btn unc-btn">
          UNC <i class="fas fa-code"></i>
        </button>
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      <button class="${finalPriceButtonClasses}">
        <div class="default-text">
          <i class="fas fa-tag"></i> BUY
        </div>
        <div class="price-text">
          <i class="fas fa-tag"></i> ${exploit.price} ${exploit.period ? `<span class="prc-prd">${exploit.period}</span>` : ""}
        </div>
      </button>
    `
      }
    }
  }

  syncPriceButtonColors() {
    document.querySelectorAll(".exp-crd, .exp-lst-itm").forEach((cardElement) => {
      const exploit = this.findExploitByCardElement(cardElement)
      const priceButton = cardElement.querySelector(".prc-btn-new")

      if (priceButton && exploit) {
        if (exploit.pricegray === true) {
          priceButton.classList.add("pricegray-disabled")
          const webButton = cardElement.querySelector(".web-btn")
          if (webButton) {
            const webButtonComputedStyle = window.getComputedStyle(webButton)
            const webButtonBgColor = webButtonComputedStyle.backgroundColor
            const webButtonTextColor = webButtonComputedStyle.color
            const webButtonBorderColor = webButtonComputedStyle.borderColor

            priceButton.style.backgroundColor = webButtonBgColor
            priceButton.style.color = webButtonTextColor
            priceButton.style.borderColor = webButtonBorderColor

            priceButton.querySelectorAll(".default-text, .price-text").forEach((child) => {
              child.style.color = webButtonTextColor
              const iconInChild = child.querySelector(".fas.fa-tag")
              if (iconInChild) {
                iconInChild.style.color = "white"
              }
            })
            const prcPrdElement = priceButton.querySelector(".prc-prd")
            if (prcPrdElement) {
              prcPrdElement.style.color = webButtonTextColor
            }
          }
        } else {
          priceButton.style.backgroundColor = ""
          priceButton.style.color = ""
          priceButton.style.borderColor = ""
          priceButton.querySelectorAll(".default-text, .price-text, .prc-prd").forEach((child) => {
            child.style.color = ""
            const iconInChild = child.querySelector(".fas.fa-tag")
            if (iconInChild) {
              iconInChild.style.color = ""
            }
          })
        }
      }
    })
  }

  static processSuncLinks(exploits) {
    return exploits.map(exploit => {
      
      if (exploit.uncbuttonlink && exploit.uncbuttonlink.includes('sunc.rubis.app')) {
        try {
          const url = new URL(exploit.uncbuttonlink)
          const scrapParam = url.searchParams.get('scrap')
          const keyParam = url.searchParams.get('key')
          
          
          if (scrapParam && keyParam) {
            return {
              ...exploit,
              scrapId: scrapParam,
              key: keyParam,
              widget: true
            }
          }
        } catch (error) {
          console.warn(`Failed to parse sunc URL for exploit ${exploit.id}:`, error)
        }
      }
      
      return exploit
    })
  }

  setupCardButtons() {
    const setupButtonHandlers = () => {
      document.querySelectorAll(".unc-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              
              const uniquePlatforms = [...new Set(exploit.plat)]
              
              
              if (uniquePlatforms.length > 1) {
                ModalManager.openPlatformModal(exploit)
                return
              }
              
              
              if (exploit.uncbuttonlink && exploit.uncbuttonlink.includes('sunc.rubis.app')) {
                try {
                  const url = new URL(exploit.uncbuttonlink)
                  const scrapParam = url.searchParams.get('scrap')
                  const keyParam = url.searchParams.get('key')
                  
                  if (scrapParam && keyParam) {
                    
                    const suncExploit = {
                      ...exploit,
                      scrapId: scrapParam,
                      key: keyParam,
                      widget: true
                    }
                    ModalManager.openSuncWidget(suncExploit)
                    return
                  }
                } catch (error) {
                  console.warn(`Failed to parse sunc URL for exploit ${exploit.id}:`, error)
                }
              }

              if (uniquePlatforms.length > 1) {
                ModalManager.openPlatformModal(exploit)
                return
              }
            
            
            if (exploit.widget === true) {
                  ModalManager.openSuncWidget(exploit)
                } else {
                  if (exploit.uncbuttonlink && exploit.uncbuttonlink.length > 0) {
                    window.open(exploit.uncbuttonlink, "_blank")
                  } else {
                    
                    ModalManager.fetchUncDataForPlatform(exploit, uniquePlatforms[0])
                  }
                }
          }
        }
        }
      })

      

      document.querySelectorAll(".info-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              ModalManager.openInfoModal(exploit)
            }
          }
        }
      })

      document.querySelectorAll(".web-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              
              if (exploit.warning === true) {
                ModalManager.showWarningModal(exploit, 'website')
              } else if (exploit.href) {
                window.open(exploit.href, "_blank")
              }
            }
          }
        }
      })

      document.querySelectorAll(".prc-btn-new").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true
          button.onclick = (e) => {
            e.preventDefault()
            e.stopPropagation()

            const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm")
            const exploit = this.findExploitByCardElement(card)

            if (exploit) {
              
              if (exploit.warning === true) {
                ModalManager.showWarningModal(exploit, 'price')
              } else if (exploit.priceHref) {
                window.open(exploit.priceHref, "_blank")
              }
            }
          }
        }
      })
      this.syncPriceButtonColors()
    }

    setupButtonHandlers()

    const observer = new MutationObserver((mutations) => {
      let shouldReSync = false
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const node = mutation.addedNodes[i]
            if (
              node.nodeType === 1 &&
              (node.classList.contains("exp-crd") ||
                node.classList.contains("exp-lst-itm") ||
                node.querySelector(".exp-crd") ||
                node.querySelector(".exp-lst-itm"))
            ) {
              shouldReSync = true
              break
            }
          }
        }
      })

      if (shouldReSync) {
        setupButtonHandlers()
      }
    })

    observer.observe(document.body, { childList: true, subtree: true })

    this.syncPriceButtonColors()

    document.head.insertAdjacentHTML(
      "beforeend",
      `
<style>
.crd-btn.expanded {
  flex: 1;
  min-width: 0;
}
.crd-btn.full-width {
  width: 100%;
}
</style>
`,
    )
  }

  findExploitByCardElement(element) {
    if (!element) return null

    const dataName = element.getAttribute("data-name")
    if (dataName) {
      return expData.find((exp) => exp.name === dataName)
    }

    const nameElement = element.querySelector(".crd-ttl") || element.querySelector(".lst-itm-ttl")
    if (nameElement) {
      const fullText = nameElement.textContent.trim()
      const cleanName = fullText.replace(/Verified|Premium|Warning|Updated|Down|Unknown|Untracked/g, "").trim()

      let exploit = expData.find((exp) => exp.name === cleanName)

      if (!exploit) {
        exploit = expData.find((exp) => cleanName.startsWith(exp.name))
      }

      return exploit
    }

    return null
  }

  updateCounts() {
    const filteredCount = this.getElement("filteredCount")
    const totalCount = this.getElement("totalCount")

    if (filteredCount) {
      this.animateCounter(
        filteredCount,
        Number.parseInt(filteredCount.textContent) || 0,
        this.appState.filteredData.length,
      )
    }

    if (totalCount) {
      this.animateCounter(totalCount, Number.parseInt(totalCount.textContent) || 0, expData.length)
    }
  }

  animateCounter(element, start, end) {
    if (!element || start === end) return

    if (element._countAnimation) {
      cancelAnimationFrame(element._countAnimation)
    }

    const duration = 800
    const startTime = performance.now()

    const updateCount = (timestamp) => {
      const elapsed = timestamp - startTime
      const progress = Math.min(elapsed / duration, 1)

      const easeOutQuart = (x) => 1 - Math.pow(1 - x, 4)
      const easedProgress = easeOutQuart(progress)

      const currentCount = Math.floor(start + (end - start) * easedProgress)

      element.textContent = currentCount

      if (progress < 1) {
        element._countAnimation = requestAnimationFrame(updateCount)
      } else {
        element.textContent = end
        element._countAnimation = null
      }
    }

    element._countAnimation = requestAnimationFrame(updateCount)
  }

  initTextSwitching() {
    const containers = document.querySelectorAll(
      ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container",
    )

    containers.forEach((container) => {
      const texts = container.querySelectorAll(".text-switch")

      container.style.position = "relative"
      container.style.display = "inline-flex"
      container.style.alignItems = "center"
      container.style.justifyContent = "center"
      container.style.minHeight = "20px"
      container.style.minWidth = "40px"

      texts.forEach((text) => {
        text.style.position = "absolute"
        text.style.top = "0"
        text.style.left = "0"
        text.style.width = "100%"
        text.style.height = "100%"
        text.style.display = "flex"
        text.style.alignItems = "center"
        text.style.justifyContent = "center"
        text.style.transition = "opacity 0.5s ease-in-out"
        text.style.opacity = text.classList.contains("visible") ? "1" : "0"
        text.style.pointerEvents = "none"
      })
    })

    const animationInterval = setInterval(() => {
      const currentContainers = document.querySelectorAll(
        ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container",
      )

      currentContainers.forEach((container) => {
        const visibleText = container.querySelector(".text-switch.visible")
        const hiddenText = container.querySelector(".text-switch.hidden")

        if (visibleText && hiddenText) {
          visibleText.style.opacity = "0"

          setTimeout(() => {
            visibleText.classList.remove("visible")
            visibleText.classList.add("hidden")
            hiddenText.classList.remove("hidden")
            hiddenText.classList.add("visible")
            hiddenText.offsetWidth
            setTimeout(() => {
              hiddenText.style.opacity = "1"
            }, 50)
          }, 250)
        }
      })
    }, 3000)

    this.textSwitchingInterval = animationInterval
  }

  updateScrollbarStyles() {
    const scrollableElements = [
      ".crd-cntnt",
      ".unc-modal-code",
      ".unc-modal-content",
      ".info-modal-content",
      ".info-modal-markdown",
      ".fltr-drwr-bdy",
    ]

    scrollableElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector)
      elements.forEach((el) => {
        el.style.overflow = "hidden"
        void el.offsetHeight
        el.style.overflow = ""
      })
    })
  }

  handleWindowResize() {
    const grid = this.getElement("grid")
    const menu = this.getElement("menu")
    const menuToggle = this.getElement("menuToggle")
    const windowWidth = window.innerWidth

    if (grid) {
      if (windowWidth < 640) {
        grid.style.gridTemplateColumns = "1fr"
      } else if (windowWidth < 1024) {
        grid.style.gridTemplateColumns = "repeat(auto-fill, minmax(280px, 1fr))"
      } else {
        grid.style.gridTemplateColumns = "repeat(auto-fill, minmax(300px, 1fr))"
      }
    }

    if (windowWidth > 768 && menu && !menu.classList.contains("hidden")) {
      menu.classList.add("hidden")
      document.body.classList.remove("menu-open")
     
    }

    this.adjustSearchBar()

    if (this.appState.paginationManager) {
      this.appState.paginationManager.render()
    }
  }

  adjustSearchBar() {
    const searchContainer = document.querySelector(".hdr-ctr")
    const headerContainer = document.querySelector(".hdr-cntr")
    const filterButton = this.getElement("filterButton")
    const logoSection = document.querySelector(".hdr-lft")
    const searchInput = document.querySelector(".srch-inp")
    const searchIcon = document.querySelector(".srch-ico")

    if (!searchContainer || !headerContainer || !filterButton || !logoSection || !searchInput || !searchIcon) return

    const windowWidth = window.innerWidth

    if (windowWidth <= 768) {
      searchContainer.style.display = "none"
      return
    }

    searchContainer.style.display = "block"
    searchContainer.style.position = "absolute"
    searchContainer.style.left = "50%"
    searchContainer.style.transform = "translateX(-50%)"
    searchContainer.style.maxWidth = "400px"
    searchContainer.style.width = "auto"
    searchContainer.style.zIndex = "5"
  }

  createModals() {
    ModalManager.createUncModal()
    ModalManager.createInfoModal()
    ModalManager.createWarningModal()
  }

  setupDropdowns() {
    const pageOverlay = document.getElementById("pageOverlay") || document.createElement("div")

    if (!document.getElementById("pageOverlay")) {
      pageOverlay.id = "pageOverlay"
      pageOverlay.className = "page-overlay"
      document.body.appendChild(pageOverlay)
    }

    const dropdowns = document.querySelectorAll(".custom-dropdown")

    dropdowns.forEach((dropdown) => {
      const selected = dropdown.querySelector(".custom-dropdown-selected")
      const options = dropdown.querySelector(".custom-dropdown-options")
      const optionItems = dropdown.querySelectorAll(".custom-dropdown-option")

      if (selected) {
        selected.addEventListener("click", (e) => {
          e.stopPropagation()

          dropdowns.forEach((d) => {
            if (d !== dropdown && d.classList.contains("active")) {
              d.classList.remove("active")
            }
          })

          dropdown.classList.toggle("active")

          if (dropdown.classList.contains("active")) {
            pageOverlay.classList.add("active")
          } else {
            pageOverlay.classList.remove("active")
          }
        })
      }

      if (optionItems) {
        optionItems.forEach((option) => {
          option.addEventListener("click", () => {
            const value = option.getAttribute("data-value")
            const text = option.textContent

            if (selected && selected.querySelector("span")) {
              selected.querySelector("span").textContent = text
            }

            optionItems.forEach((opt) => opt.classList.remove("selected"))
            option.classList.add("selected")

            dropdown.classList.remove("active")
            pageOverlay.classList.remove("active")

            if (dropdown.closest(".srt-fltr-cntr") || dropdown.closest(".mob-srt-fltr-cntr")) {
              this.appState.sortBy = value
              this.updateExploits()
            }
          })
        })
      }
    })

    pageOverlay.addEventListener("click", () => {
      dropdowns.forEach((dropdown) => {
        dropdown.classList.remove("active")
      })

      pageOverlay.classList.remove("active")
    })
  }
}

class ModalManager {
  static createUncModal() {
    const modalContainer = document.createElement("div")
    modalContainer.className = "unc-modal-container"
    modalContainer.id = "uncModalContainer"
    modalContainer.style.display = "none"

    modalContainer.innerHTML = `
<div class="unc-modal-overlay" id="uncModalOverlay"></div>
<div class="unc-modal">
  <div class="unc-modal-header">
    <h2 class="unc-modal-title" id="uncModalTitle">UNC Code</h2>
  </div>
  <div class="unc-modal-content">
    <div class="unc-modal-info">
      <div class="unc-modal-exploit-info" id="uncModalExploitInfo">
        <div class="unc-modal-exploit-name" id="uncModalExploitName"></div>
        <div class="unc-modal-exploit-desc" id="uncModalExploitDesc"></div>
      </div>
    </div>
    <div class="unc-modal-code-container">
      <div class="unc-modal-code-header">
        <div class="unc-modal-code-title">UNC Code</div>
        <button class="unc-modal-copy-btn" id="uncModalCopyBtn">
          <i class="fas fa-copy"></i> Copy
        </button>
      </div>
      <pre class="unc-modal-code" id="uncModalCode"></pre>
    </div>
    <div class="unc-modal-loading" id="uncModalLoading">
      <div class="unc-modal-spinner"></div>
      <div class="unc-modal-loading-text">Loading UNC data...</div>
    </div>
    <div class="unc-modal-error" id="uncModalError">
      <i class="fas fa-exclamation-triangle"></i>
      <div class="unc-modal-error-text" id="uncModalErrorText">Failed to load UNC data</div>
    </div>
  </div>
  <div class="unc-modal-footer">
    <button class="unc-modal-btn unc-modal-btn-primary" id="uncModalCloseBtn">
      <i class="fas fa-times"></i> Close
    </button>
  </div>
</div>
`

    document.body.appendChild(modalContainer)

    document.getElementById("uncModalOverlay").addEventListener("click", ModalManager.closeUncModal)
    document.getElementById("uncModalCloseBtn").addEventListener("click", ModalManager.closeUncModal)

    document.getElementById("uncModalCopyBtn").addEventListener("click", () => {
      const codeElement = document.getElementById("uncModalCode")

      if (codeElement) {
        navigator.clipboard.writeText(codeElement.textContent || "")

        const copyBtn = document.getElementById("uncModalCopyBtn")
        const originalText = copyBtn.innerHTML

        copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!'

        setTimeout(() => {
          copyBtn.innerHTML = originalText
        }, 2000)
      }
    })
  }

  static openSuncWidget(exploit) {
  
  const modalId = `suncWidgetModalContainer_${exploit.id}`
  let modalContainer = document.getElementById(modalId)

  if (!modalContainer) {
    ModalManager.createSuncWidgetModal(exploit.id)
    modalContainer = document.getElementById(modalId)
  }

  const widgetIframe = document.getElementById(`suncWidgetIframe_${exploit.id}`)

  modalContainer.style.display = "flex"

  widgetIframe.src = "https://sunc.rubis.app/widget"
  widgetIframe.setAttribute("data-scrap-id", exploit.scrapId || "")
  widgetIframe.setAttribute("data-key", exploit.key || "")

  widgetIframe.onload = () => {
    if (exploit.scrapId && exploit.key) {
      ModalManager.postMessageToWidget(widgetIframe, {
        type: "sunc-widget:loadScrap",
        payload: {
          scrapId: exploit.scrapId,
          key: exploit.key,
        },
      })
    }
  }

  setTimeout(() => {
    document.querySelector(`#${modalId} .sunc-widget-modal`).classList.add("show")
  }, 10)

  document.body.style.overflow = "hidden"
}

  static closeSuncWidget(exploitId = null) {
  if (exploitId) {
    const modal = document.querySelector(`#suncWidgetModalContainer_${exploitId} .sunc-widget-modal`)
    
    if (modal) {
      modal.classList.remove("show")

      setTimeout(() => {
        const container = document.getElementById(`suncWidgetModalContainer_${exploitId}`)
        if (container) {
          container.style.display = "none"
        }
        
        const openWidgets = document.querySelectorAll('.sunc-widget-modal-container[style*="flex"]')
        if (openWidgets.length <= 1) {
          document.body.style.overflow = ""
        }
      }, 300)
    }
  } else {
    
    const modals = document.querySelectorAll(".sunc-widget-modal")
    
    modals.forEach(modal => {
      modal.classList.remove("show")
    })

    setTimeout(() => {
      const containers = document.querySelectorAll('[id^="suncWidgetModalContainer_"]')
      containers.forEach(container => {
        container.style.display = "none"
      })
      document.body.style.overflow = ""
    }, 300)
  }
}

  static createSuncWidgetModal(exploitId) {
    
    const modalContainer = document.createElement("div")
    modalContainer.className = "sunc-widget-modal-container"
    modalContainer.id = `suncWidgetModalContainer_${exploitId}`
    modalContainer.style.display = "none"

    modalContainer.innerHTML = `
  <div class="sunc-widget-modal-overlay" onclick="ModalManager.closeSuncWidget('${exploitId}')"></div>
  <div class="sunc-widget-modal">
    <button class="sunc-widget-close-btn" onclick="ModalManager.closeSuncWidget('${exploitId}')">
      <i class="fas fa-times"></i>
    </button>
    <iframe 
      id="suncWidgetIframe_${exploitId}"
      class="sunc-widget-iframe-modal"
      frameborder="0">
    </iframe>
  </div>
  `

    document.body.appendChild(modalContainer)
  }

  static createPlatformModal() {
    const modalContainer = document.createElement("div")
    modalContainer.className = "platform-modal-container"
    modalContainer.id = "platformModalContainer"
    modalContainer.style.display = "none"

    modalContainer.innerHTML = `
      <div class="platform-modal-overlay"></div>
      <div class="platform-modal">
        <div class="platform-modal-header">
          <h2 class="platform-modal-title">Select Platform</h2>
          <p class="platform-modal-subtitle">Choose your platform to view the correct UNC</p>
        </div>
        <div class="platform-modal-content">
          <div id="platformOptions" class="platform-options"></div>
        </div>
        <div class="platform-modal-footer">
          <button id="platformModalCancel" class="platform-modal-btn platform-modal-btn-cancel">Cancel</button>
        </div>
      </div>
    `

    document.body.appendChild(modalContainer)

    document.querySelector(".platform-modal-overlay").addEventListener("click", ModalManager.closePlatformModal)
    document.getElementById("platformModalCancel").addEventListener("click", ModalManager.closePlatformModal)
  }

  static openPlatformModal(exploit) {
  let modalContainer = document.getElementById("platformModalContainer")
  
  if (!modalContainer) {
    ModalManager.createPlatformModal()
    modalContainer = document.getElementById("platformModalContainer")
  }

  const platformOptions = document.getElementById("platformOptions")
  platformOptions.innerHTML = ""

  const uniquePlatforms = [...new Set(exploit.plat)]
  
  uniquePlatforms.forEach((platform) => {
    const platformButton = document.createElement("button")
    platformButton.className = "platform-option-btn"
    
    let iconHtml = ""
    let platformName = ""
    
    switch (platform) {
      case "windows":
        iconHtml = `<i class="fab fa-windows"></i>`
        platformName = "Windows"
        break
      case "macos":
        iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:24px; height:24px;">`
        platformName = "macOS"
        break
      case "android":
        iconHtml = `<i class="fab fa-android"></i>`
        platformName = "Android"
        break
      case "ios":
        iconHtml = `<i class="fab fa-apple"></i>`
        platformName = "iOS"
        break
    }
    
    platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `
    
    platformButton.onclick = () => {
      ModalManager.closePlatformModal()
      ModalManager.fetchUncDataForPlatform(exploit, platform)
    }
    
    platformOptions.appendChild(platformButton)
  })

  modalContainer.style.display = "flex"
  
  setTimeout(() => {
    document.querySelector(".platform-modal").classList.add("show")
  }, 10)

  document.body.style.overflow = "hidden"
}

  static closePlatformModal() {
    const modal = document.querySelector(".platform-modal")
    
    if (modal) {
      modal.classList.remove("show")
      
      setTimeout(() => {
        const container = document.getElementById("platformModalContainer")
        if (container) {
          container.style.display = "none"
        }
        document.body.style.overflow = ""
      }, 300)
    }
  }

  static async fetchUncDataForPlatform(exploit, platform) {
    const modalContainer = document.getElementById("uncModalContainer")
    
    if (!modalContainer) {
      ModalManager.createUncModal()
    }

    const modalContainer2 = document.getElementById("uncModalContainer")
    const modalTitle = document.getElementById("uncModalTitle")
    const modalExploitName = document.getElementById("uncModalExploitName")
    const modalExploitDesc = document.getElementById("uncModalExploitDesc")
    const modalCode = document.getElementById("uncModalCode")
    const modalLoading = document.getElementById("uncModalLoading")
    const modalError = document.getElementById("uncModalError")

    modalContainer2.style.display = "flex"
    modalTitle.textContent = `${exploit.name} UNC Code (${platform})`
    modalExploitName.textContent = exploit.name
    modalExploitDesc.textContent = exploit.desc

    modalLoading.style.display = "flex"
    modalCode.style.display = "none"
    modalError.style.display = "none"

    try {
      const response = await fetch(`https://voxlis.net/assets/unc/${platform}/${exploit.id}.json`)
      
      if (response.status === 404) {
        ModalManager.showNotification(`UNC/sUNC test for ${exploit.name} on ${platform} is unknown`, "error")
        throw new Error("UNC data not found")
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const rawText = await response.text()
      
      modalLoading.style.display = "none"
      modalCode.style.display = "block"
      modalCode.textContent = rawText || "-- No UNC code available"

      if (window.hljs) {
        window.hljs.highlightElement(modalCode)
      }
    } catch (error) {
      modalLoading.style.display = "none"
      modalError.style.display = "flex"
      document.getElementById("uncModalErrorText").textContent =
        `Failed to load UNC data: ${error.message || "Unknown error"}`
    }

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show")
    }, 10)

    document.body.style.overflow = "hidden"
  }

  static postMessageToWidget(iframe, message) {
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage(message, "https://sunc.rubis.app")
    }
  }

  static createInfoModal() {
    const modalContainer = document.getElementById("infoModalContainer")

    if (modalContainer) {
      document.getElementById("infoModalOverlay").addEventListener("click", ModalManager.closeInfoModal)
      document.getElementById("infoModalCloseBtn").addEventListener("click", ModalManager.closeInfoModal)

      const footerCloseBtn = document.getElementById("infoModalFooterCloseBtn")

      if (footerCloseBtn) {
        footerCloseBtn.addEventListener("click", ModalManager.closeInfoModal)
      }
    }
  }

  static openPlatformModal(exploit) {
  const modalContainer = document.getElementById("platformModal")
  
  if (!modalContainer) {
    console.error("Platform modal not found in HTML")
    return
  }

  const platformOptions = document.getElementById("platformOptions")
  platformOptions.innerHTML = ""

  const uniquePlatforms = [...new Set(exploit.plat)]
  
  uniquePlatforms.forEach((platform) => {
    const platformButton = document.createElement("button")
    platformButton.className = "platform-option-btn"
    
    let iconHtml = ""
    let platformName = ""
    
    switch (platform) {
      case "windows":
        iconHtml = `<i class="fab fa-windows"></i>`
        platformName = "Windows"
        break
      case "macos":
        iconHtml = `<i class="fab fa-apple"></i>`
        platformName = "macOS"
        break
      case "android":
        iconHtml = `<i class="fab fa-android"></i>`
        platformName = "Android"
        break
      case "ios":
        iconHtml = `<i class="fab fa-apple"></i>`
        platformName = "iOS"
        break
    }
    
    platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `
    
    platformButton.onclick = () => {
      ModalManager.closePlatformModal()
      ModalManager.fetchUncDataForPlatform(exploit, platform)
    }
    
    platformOptions.appendChild(platformButton)
  })

  modalContainer.style.display = "flex"
  
  setTimeout(() => {
    document.querySelector(".platform-modal").classList.add("show")
  }, 10)

  document.body.style.overflow = "hidden"
  
  
  const overlay = modalContainer.querySelector(".platform-modal-overlay")
  const cancelBtn = document.getElementById("platformModalCancel")
  
  overlay.onclick = () => ModalManager.closePlatformModal()
  cancelBtn.onclick = () => ModalManager.closePlatformModal()
}

static closePlatformModal() {
  const modal = document.querySelector(".platform-modal")
  
  if (modal) {
    modal.classList.remove("show")
    
    setTimeout(() => {
      const container = document.getElementById("platformModal")
      if (container) {
        container.style.display = "none"
      }
      document.body.style.overflow = ""
    }, 300)
  }
}

  static async fetchUncDataForPlatform(exploit, platform) {
    const modalContainer = document.getElementById("uncModalContainer")
    
    if (!modalContainer) {
      ModalManager.createUncModal()
    }

    const modalContainer2 = document.getElementById("uncModalContainer")
    const modalTitle = document.getElementById("uncModalTitle")
    const modalExploitName = document.getElementById("uncModalExploitName")
    const modalExploitDesc = document.getElementById("uncModalExploitDesc")
    const modalCode = document.getElementById("uncModalCode")
    const modalLoading = document.getElementById("uncModalLoading")
    const modalError = document.getElementById("uncModalError")

    modalContainer2.style.display = "flex"
    modalTitle.textContent = `${exploit.name} UNC Code (${platform.charAt(0).toUpperCase() + platform.slice(1)})`
    modalExploitName.textContent = exploit.name
    modalExploitDesc.textContent = exploit.desc

    modalLoading.style.display = "flex"
    modalCode.style.display = "none"
    modalError.style.display = "none"

    try {
      const response = await fetch(`https://voxlis.net/assets/unc/${platform}/${exploit.id}.json`)
      
      if (response.status === 404) {
        ModalManager.showNotification(`UNC/sUNC test for ${exploit.name} on ${platform} is unknown`, "error")
        throw new Error("UNC data not found")
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const rawText = await response.text()
      
      modalLoading.style.display = "none"
      modalCode.style.display = "block"
      modalCode.textContent = rawText || "-- No UNC code available"

      if (window.hljs) {
        window.hljs.highlightElement(modalCode)
      }
    } catch (error) {
      modalLoading.style.display = "none"
      modalError.style.display = "flex"
      document.getElementById("uncModalErrorText").textContent =
        `Failed to load UNC data: ${error.message || "Unknown error"}`
    }

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show")
    }, 10)

    document.body.style.overflow = "hidden"
  }

  static createWarningModal() {
    const modalContainer = document.createElement("div")
    modalContainer.id = "warningModal"
    modalContainer.className = "warning-modal-container"
    modalContainer.style.display = "none"

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <h2 class="warning-modal-title">Warning</h2>
  </div>
  <div class="warning-modal-content">
    <div class="warning-modal-icon">
      <i class="fas fa-exclamation-triangle"></i>
    </div>
    <p id="warningModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
  </div>
  <div class="warning-modal-footer">
    <button id="warningModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="warningModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
  </div>
</div>
`

    document.body.appendChild(modalContainer)
  }

  static openUncModal(exploit) {
    const modalContainer = document.getElementById("uncModalContainer")

    if (!modalContainer) {
      ModalManager.createUncModal()
    }

    const modalContainer2 = document.getElementById("uncModalContainer")
    const modalTitle = document.getElementById("uncModalTitle")
    const modalExploitName = document.getElementById("uncModalExploitName")
    const modalExploitDesc = document.getElementById("uncModalExploitDesc")
    const modalCode = document.getElementById("uncModalCode")
    const modalLoading = document.getElementById("uncModalLoading")
    const modalError = document.getElementById("uncModalError")

    modalContainer2.style.display = "flex"
    modalTitle.textContent = `${exploit.name} UNC Code`
    modalExploitName.textContent = exploit.name
    modalExploitDesc.textContent = exploit.desc

    modalLoading.style.display = "flex"
    modalCode.style.display = "none"
    modalError.style.display = "none"

    ModalManager.fetchUncData(exploit.id, exploit.name)
      .then((data) => {
        modalLoading.style.display = "none"
        modalCode.style.display = "block"
        modalCode.textContent = data.code || "-- No UNC code available"

        if (window.hljs) {
          window.hljs.highlightElement(modalCode)
        }
      })
      .catch((error) => {
        modalLoading.style.display = "none"
        modalError.style.display = "flex"
        document.getElementById("uncModalErrorText").textContent =
          `Failed to load UNC data: ${error.message || "Unknown error"}`
      })

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show")
    }, 10)

    document.body.style.overflow = "hidden"
  }

  static closeUncModal() {
    const modal = document.querySelector(".unc-modal")

    if (modal) {
      modal.classList.remove("show")

      setTimeout(() => {
        const container = document.getElementById("uncModalContainer")

        if (container) {
          container.style.display = "none"
        }

        document.body.style.overflow = ""
      }, 300)
    }
  }

  static openInfoModal(exploit) {
    const modalContainer = document.getElementById("infoModalContainer")
    const modalTitle = document.getElementById("infoModalTitle")
    const modalExploitName = document.getElementById("infoModalExploitName")
    const modalExploitDesc = document.getElementById("infoModalExploitDesc")
    const modalMarkdown = document.getElementById("infoModalMarkdown")

    modalContainer.style.display = "flex"
    modalTitle.textContent = `${exploit.name} Information`
    modalExploitName.textContent = exploit.name
    modalExploitDesc.textContent = exploit.desc

    if (exploit.info) {
      const marked = window.marked
      modalMarkdown.innerHTML = marked.parse(exploit.info)

      if (window.hljs) {
        document.querySelectorAll("#infoModalMarkdown pre code").forEach((block) => {
          window.hljs.highlightElement(block)
        })
      }
    } else {
      modalMarkdown.innerHTML = "<p>No additional information available for this exploit.</p>"
    }

    setTimeout(() => {
      document.querySelector(".info-modal").classList.add("show")
    }, 10)

    document.body.style.overflow = "hidden"
  }

  static closeInfoModal() {
    const modal = document.querySelector(".info-modal")

    if (modal) {
      modal.classList.remove("show")

      setTimeout(() => {
        const container = document.getElementById("infoModalContainer")

        if (container) {
          container.style.display = "none"
        }

        document.body.style.overflow = ""
      }, 300)
    }
  }

  static showWarningModal(exploit, buttonType = 'website') {
  const warningModal = document.getElementById("warningModal")
  const warningData = exploit.modals?.warning
  
  if (warningData && warningData.enabled === false) {
    
    const targetUrl = buttonType === 'price' ? exploit.priceHref : exploit.href
    if (targetUrl) {
      window.open(targetUrl, "_blank")
    }
    return
  }

  const warningText = document.getElementById("warningModalText")
  const cancelBtn = document.getElementById("warningModalCancel")
  const okayBtn = document.getElementById("warningModalOkay")
  
  const targetUrl = buttonType === 'price' ? exploit.priceHref : exploit.href

  warningText.textContent = warningData?.desc || exploit.warningInfo || "Are you sure you want to visit this website?"
  
  warningModal.style.display = "flex"
  document.body.style.overflow = "hidden"
  warningModal.classList.add("active")

  okayBtn.disabled = true
  okayBtn.classList.add('loading-state')
  
  const progressWrapper = document.createElement('div')
  progressWrapper.className = 'progress-wrapper'
  
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  svg.setAttribute('class', 'progress-border-svg')
  
  const btnWidth = okayBtn.offsetWidth
  const btnHeight = okayBtn.offsetHeight
  const borderRadius = 6
  const strokeWidth = 2
  
  const padding = strokeWidth / 2
  const x = padding
  const y = padding
  const width = btnWidth - strokeWidth
  const height = btnHeight - strokeWidth
  const r = borderRadius
  
  const pathData = `
    M ${x + r} ${y}
    L ${x + width - r} ${y}
    Q ${x + width} ${y} ${x + width} ${y + r}
    L ${x + width} ${y + height - r}
    Q ${x + width} ${y + height} ${x + width - r} ${y + height}
    L ${x + r} ${y + height}
    Q ${x} ${y + height} ${x} ${y + height - r}
    L ${x} ${y + r}
    Q ${x} ${y} ${x + r} ${y}
  `
  
  const bgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path')
  bgPath.setAttribute('d', pathData)
  bgPath.setAttribute('fill', 'none')
  bgPath.setAttribute('stroke', 'rgba(255, 255, 255, 0.1)')
  bgPath.setAttribute('stroke-width', strokeWidth)
  bgPath.setAttribute('class', 'progress-bg')
  
  const progressPath = document.createElementNS('http://www.w3.org/2000/svg', 'path')
  progressPath.setAttribute('d', pathData)
  progressPath.setAttribute('fill', 'none')
  progressPath.setAttribute('stroke', 'var(--prim)')
  progressPath.setAttribute('stroke-width', strokeWidth)
  progressPath.setAttribute('stroke-linecap', 'round')
  progressPath.setAttribute('class', 'progress-path')
  
  const pathLength = progressPath.getTotalLength()
  progressPath.style.strokeDasharray = pathLength
  progressPath.style.strokeDashoffset = pathLength
  
  svg.appendChild(bgPath)
  svg.appendChild(progressPath)
  progressWrapper.appendChild(svg)
  okayBtn.appendChild(progressWrapper)
  
  requestAnimationFrame(() => {
    progressPath.style.transition = 'stroke-dashoffset 5s cubic-bezier(0.4, 0, 0.2, 1)'
    progressPath.style.strokeDashoffset = '0'
  })
  
  const enableTimer = setTimeout(() => {
    okayBtn.disabled = false
    okayBtn.classList.remove('loading-state')
    okayBtn.classList.add('ready-state')
  }, 5000)

  const cleanup = () => {
    clearTimeout(enableTimer)
    okayBtn.disabled = false
    okayBtn.classList.remove('loading-state', 'ready-state')
    
    const wrapper = okayBtn.querySelector('.progress-wrapper')
    if (wrapper) {
      wrapper.remove()
    }
    
    warningModal.classList.remove("active")
    setTimeout(() => {
      warningModal.style.display = "none"
      document.body.style.overflow = ""
    }, 300)
  }

  cancelBtn.onclick = () => {
    cleanup()
  }

  okayBtn.onclick = () => {
    if (!okayBtn.disabled) {
      cleanup()
      if (targetUrl) {
        window.open(targetUrl, "_blank")
      }
    }
  }
}
  static async fetchUncData(id, name) {
    try {
      const response = await fetch(`https://voxlis.net/assets/unc/${id}.json`)

      if (response.status === 404) {
        ModalManager.showNotification(`UNC/sUNC test for ${name} is unknown`, "error")
        throw new Error("UNC data not found")
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const rawText = await response.text()
      return { code: rawText }
    } catch (error) {
      console.error("Error fetching UNC data:", error)
      throw error
    }
  }

  static showNotification(message, type = "error") {
    let container = document.getElementById("custom-notifications")

    if (!container) {
      container = document.createElement("div")
      container.id = "custom-notifications"
      container.style.position = "fixed"
      container.style.top = "20px"
      container.style.right = "20px"
      container.style.zIndex = "9999"
      container.style.display = "flex"
      container.style.flexDirection = "column"
      container.style.gap = "10px"
      document.body.appendChild(container)
    }

    const notification = document.createElement("div")
    notification.className = `custom-notification ${type}`
    notification.style.position = "relative"
    notification.style.minWidth = "320px"
    notification.style.maxWidth = "450px"
    notification.style.overflow = "hidden"
    notification.style.borderRadius = "12px"

    notification.style.boxShadow = "0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 5px 10px -5px rgba(0, 0, 0, 0.2)"
    notification.style.transform = "translateX(120%)"
    notification.style.transition = "transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s ease"
    notification.style.margin = "0 0 10px 0"
    notification.style.opacity = "1"

    const bgColor = type === "error" ? "rgba(239, 68, 68, 0.85)" : "rgba(59, 130, 246, 0.85)"
    notification.style.background = bgColor
    notification.style.backdropFilter = "blur(10px)"
    notification.style.border =
      type === "error" ? "1px solid rgba(248, 113, 113, 0.4)" : "1px solid rgba(96, 165, 250, 0.4)"

    const content = document.createElement("div")
    content.style.padding = "16px 20px"
    content.style.display = "flex"
    content.style.alignItems = "flex-start"
    content.style.gap = "15px"
    content.style.position = "relative"
    content.style.zIndex = "1"

    const decorativeLine = document.createElement("div")
    decorativeLine.style.position = "absolute"
    decorativeLine.style.top = "0"
    decorativeLine.style.left = "0"
    decorativeLine.style.width = "4px"
    decorativeLine.style.height = "100%"
    decorativeLine.style.background = "rgba(255, 255, 255, 0.9)"
    decorativeLine.style.borderRadius = "2px"
    content.appendChild(decorativeLine)

    const iconContainer = document.createElement("div")
    iconContainer.style.display = "flex"
    iconContainer.style.alignItems = "center"
    iconContainer.style.justifyContent = "center"
    iconContainer.style.width = "32px"
    iconContainer.style.height = "32px"
    iconContainer.style.borderRadius = "50%"
    iconContainer.style.flexShrink = "0"

    const icon = document.createElement("i")
    icon.className = type === "error" ? "fas fa-exclamation-circle" : "fas fa-info-circle"
    icon.style.color = "white"
    icon.style.fontSize = "16px"
    iconContainer.appendChild(icon)

    const messageContainer = document.createElement("div")
    messageContainer.style.flex = "1"

    const title = document.createElement("div")
    title.textContent = type === "error" ? "UNC Test Unavailable" : "Information"
    title.style.fontWeight = "600"
    title.style.fontSize = "14px"
    title.style.color = "white"
    title.style.marginBottom = "4px"
    title.style.letterSpacing = "0.3px"

    const messageText = document.createElement("div")
    messageText.textContent = message
    messageText.style.fontSize = "13px"
    messageText.style.color = "rgba(255, 255, 255, 0.9)"
    messageText.style.lineHeight = "1.4"

    messageContainer.appendChild(title)
    messageContainer.appendChild(messageText)

    const closeBtn = document.createElement("button")
    closeBtn.innerHTML = '<i class="fas fa-times"></i>'
    closeBtn.style.background = "none"
    closeBtn.style.border = "none"
    closeBtn.style.color = "white"
    closeBtn.style.opacity = "0.7"
    closeBtn.style.cursor = "pointer"
    closeBtn.style.fontSize = "14px"
    closeBtn.style.padding = "4px"
    closeBtn.style.marginLeft = "8px"
    closeBtn.style.transition = "all 0.2s"
    closeBtn.style.display = "flex"
    closeBtn.style.alignItems = "center"
    closeBtn.style.justifyContent = "center"
    closeBtn.style.width = "24px"
    closeBtn.style.height = "24px"
    closeBtn.style.borderRadius = "50%"

    closeBtn.addEventListener("mouseover", () => {
      closeBtn.style.opacity = "1"
      closeBtn.style.background = "rgba(255, 255, 255, 0.2)"
    })

    closeBtn.addEventListener("mouseout", () => {
      closeBtn.style.opacity = "0.7"
      closeBtn.style.background = "none"
    })

    closeBtn.addEventListener("click", () => {
      notification.style.transform = "translateX(120%)"
      notification.style.opacity = "0"

      setTimeout(() => {
        notification.remove()
      }, 500)
    })

    content.appendChild(iconContainer)
    content.appendChild(messageContainer)
    notification.appendChild(content)

    const progressBarContainer = document.createElement("div")
    progressBarContainer.style.position = "absolute"
    progressBarContainer.style.bottom = "0"
    progressBarContainer.style.left = "0"
    progressBarContainer.style.width = "100%"
    progressBarContainer.style.height = "3px"
    progressBarContainer.style.background = "rgba(0, 0, 0, 0.1)"

    const progressBar = document.createElement("div")
    progressBar.style.height = "100%"
    progressBar.style.width = "100%"
    progressBar.style.background = "rgba(255, 255, 255, 0.7)"
    progressBar.style.transition = "width 5s cubic-bezier(0.1, 0.5, 0.2, 1)"

    progressBarContainer.appendChild(progressBar)
    notification.appendChild(progressBarContainer)

    container.appendChild(notification)

    setTimeout(() => {
      notification.style.transform = "translateX(0)"
    }, 10)

    setTimeout(() => {
      progressBar.style.width = "0"
    }, 100)

    setTimeout(() => {
      notification.style.transform = "translateX(120%)"
      notification.style.opacity = "0"

      setTimeout(() => {
        notification.remove()
      }, 5000)
    })
  }
}

class ThemeManager {
  constructor() {
    this.currentTheme = localStorage.getItem("voxlis-theme") || "red"
  }

  init() {
    document.documentElement.setAttribute("data-theme", this.currentTheme)

    this.updateLogo()
    this.setupThemeDropdown()
    this.updateThemeElements()

    return this
  }

  setupThemeDropdown() {
    const themeDropdown = document.getElementById("themeDropdown")
    const themeDropdownSelected = document.getElementById("themeDropdownSelected")
    const themeDropdownOptions = document.getElementById("themeDropdownOptions")

    if (themeDropdown && themeDropdownSelected && themeDropdownOptions) {
      this.updateSelectedTheme(document.documentElement.getAttribute("data-theme") || "red")

      themeDropdownSelected.addEventListener("click", () => {
        themeDropdown.classList.toggle("active")
      })

      document.addEventListener("click", (e) => {
        if (!themeDropdown.contains(e.target)) {
          themeDropdown.classList.remove("active")
        }
      })

      const themeOptions = themeDropdownOptions.querySelectorAll(".theme-dropdown-option")

      themeOptions.forEach((option) => {
        option.addEventListener("click", () => {
          const theme = option.getAttribute("data-theme")
          document.documentElement.setAttribute("data-theme", theme)
          this.currentTheme = theme
          this.updateSelectedTheme(theme)
          localStorage.setItem("voxlis-theme", theme)
          this.createThemeChangeEffect(theme)
          setTimeout(() => this.updateThemeElements(), this.updateLogo(), 100)
        })
      })
    }
  }

  updateSelectedTheme(theme) {
    const themeDropdownSelected = document.getElementById("themeDropdownSelected")
    const themeDropdownOptions = document.getElementById("themeDropdownOptions")

    if (themeDropdownSelected && themeDropdownOptions) {
      const themeName = theme.charAt(0).toUpperCase() + theme.slice(1)

      themeDropdownSelected.innerHTML = `
    <div class="theme-color-indicator ${theme}"></div>
    <span>${themeName} Theme</span>
    <i class="fas fa-chevron-down"></i>
`

      const options = themeDropdownOptions.querySelectorAll(".theme-dropdown-option")

      options.forEach((option) => {
        option.classList.remove("selected")

        if (option.getAttribute("data-theme") === theme) {
          option.classList.add("selected")
        }
      })
    }
  }

  createThemeChangeEffect(theme) {
    const themeColor = getComputedStyle(document.documentElement).getPropertyValue("--theme-color").trim()

    const ripple = document.createElement("div")
    ripple.style.position = "fixed"
    ripple.style.top = "50%"
    ripple.style.left = "50%"
    ripple.style.transform = "translate(-50%, -50%)"
    ripple.style.width = "10px"
    ripple.style.height = "10px"
    ripple.style.borderRadius = "50%"
    ripple.style.backgroundColor = themeColor
    ripple.style.transition = "all 0.6s cubic-bezier(0.19, 1, 0.22, 1)"
    ripple.style.zIndex = "9999"

    document.body.appendChild(ripple)

    setTimeout(() => {
      ripple.style.width = "300vw"
      ripple.style.height = "300vh"
      ripple.style.opacity = "0"
    }, 10)

    setTimeout(() => {
      ripple.remove()
    }, 800)
  }

  updateLogo() {
    const logoSelectors = [".logo-img", ".footer-logo-img", ".loading-logo-img"]

    const adSelectors = ['img[src*="ad-red-voxlis"]', 'img[src*="ad-purple-voxlis"]']

    const voxlisAdSelectors = [
      'img[src*="voxlis_small.png"]',
      'img[src*="voxlis_big.png"]',
      'img[src*="_voxlis_small.png"]',
      'img[src*="_voxlis_big.png"]',
    ]

    if (window.heartAnimation && typeof window.heartAnimation.updateHeartImage === "function" && !window.heartAnimation.isLoadingTheme) {
        window.heartAnimation.updateHeartImage(this.currentTheme)
    }

    logoSelectors.forEach((selector) => {
      const logoImg = document.querySelector(selector)
      if (logoImg) {
        const themeLogoPath = `/assets/${this.currentTheme}-voxlis.png`
        const defaultLogoPath = "/assets/red-voxlis.png"

        const testImg = new Image()
        testImg.onload = () => {
          logoImg.src = themeLogoPath
        }
        testImg.onerror = () => {
          logoImg.src = defaultLogoPath
        }
        testImg.src = themeLogoPath
      }
    })

    adSelectors.forEach((selector) => {
      const adImgs = document.querySelectorAll(selector)
      adImgs.forEach((adImg) => {
        const themeAdPath = `/assets/ads/ad-${this.currentTheme}-voxlis.png`
        const defaultAdPath = "/assets/ads/ad-red-voxlis.png"

        const testImg = new Image()
        testImg.onload = () => {
          adImg.src = themeAdPath
        }
        testImg.onerror = () => {
          adImg.src = defaultAdPath
        }
        testImg.src = themeAdPath
      })
    })

    voxlisAdSelectors.forEach((selector) => {
      const adImgs = document.querySelectorAll(selector)
      adImgs.forEach((adImg) => {
        const currentSrc = adImg.src
        let newSrc

        if (currentSrc.includes("voxlis_small.png") || currentSrc.includes("_voxlis_small.png")) {
          newSrc = `/assets/ads/${this.currentTheme}_voxlis_small.png`
        } else if (currentSrc.includes("voxlis_big.png") || currentSrc.includes("_voxlis_big.png")) {
          newSrc = `/assets/ads/${this.currentTheme}_voxlis_big.png`
        }

        if (newSrc) {
          const testImg = new Image()
          testImg.onload = () => {
            adImg.src = newSrc
          }
          testImg.onerror = () => {
            
            const fallbackSrc = newSrc.replace(`${this.currentTheme}_`, "red_")
            adImg.src = fallbackSrc
          }
          testImg.src = newSrc
        }
      })
    })
  }
  updateThemeElements() {
    const theme = this.currentTheme
    let bgColor, textColor, borderColor

    const uncModal = document.querySelector(".unc-modal")

    if (uncModal) {
      uncModal.style.backgroundColor = bgColor
      uncModal.style.color = textColor
      uncModal.style.border = `1px solid ${borderColor}`

      const modalHeader = uncModal.querySelector(".unc-modal-header")
      if (modalHeader) {
        modalHeader.style.borderBottom = `1px solid ${borderColor}`
      }

      const modalFooter = uncModal.querySelector(".unc-modal-footer")
      if (modalFooter) {
        modalFooter.style.borderTop = `1px solid ${borderColor}`
      }
    }

    const infoModal = document.querySelector(".info-modal")

    if (infoModal) {
      const header = infoModal.querySelector(".info-modal-header")
      if (header) {
        header.style.background = ""
        header.style.borderBottom = ""
      }

      const exploitName = infoModal.querySelector(".info-modal-exploit-name")
      if (exploitName) {
        exploitName.style.background = ""
      }

      const closeBtn = infoModal.querySelector(".info-modal-close-btn")
      if (closeBtn) {
        closeBtn.style.backgroundColor = ""
      }

      const links = infoModal.querySelectorAll(".info-modal-markdown a")
      links.forEach((link) => {
        link.style.color = ""
      })

      const blockquote = infoModal.querySelectorAll(".info-modal-markdown blockquote")
      blockquote.forEach((bq) => {
        bq.style.backgroundColor = ""
        bq.style.borderColor = ""
        bq.style.color = ""
      })

      const codeBlocks = infoModal.querySelectorAll(".info-modal-markdown pre code")
      codeBlocks.forEach((codeBlock) => {
        codeBlock.style.background = ""
        codeBlock.style.color = ""
      })
    }

    const webButtons = document.querySelectorAll(".web-btn")
    webButtons.forEach((btn) => {
      btn.style.backgroundColor = ""
      btn.style.borderColor = ""
      btn.style.color = ""
    })

    const heroElements = document.querySelectorAll(
      ".hero-acnt-bar, .hero-ttl strong, .hero-ttl b, .hero-ttl em, .yt-tutorial-btn",
    )

    heroElements.forEach((el) => {
      el.style.background = ""
      el.style.color = ""
    })

    const checkboxes = document.querySelectorAll(
      ".cstm-chkbx.ext input:checked ~ .chkmrk, .cstm-chkbx.exec input:checked ~ .chkmrk",
    )

    checkboxes.forEach((cb) => {
      cb.style.backgroundColor = ""
      cb.style.borderColor = ""
    })
  }
}

class OptimizedHeartAnimation {
  constructor({ heartCount = 30, minHearts = 15 } = {}) {
    if (OptimizedHeartAnimation.instance) {
      return OptimizedHeartAnimation.instance
    }
    OptimizedHeartAnimation.instance = this

    this.canvas = document.getElementById("heartRainCanvas")
    this.loader = document.getElementById("loader")
    if (!this.canvas) return

    this.ctx = this.canvas.getContext("2d")
    const currentTheme = document.documentElement.getAttribute("data-theme") || "red"
    this.heartImageSrc = `/assets/${currentTheme}-heart.svg`
    this.hearts = []
    this.heartImage = new Image()
    this.isRunning = false
    this.isLoadingTheme = false
    this.lastFrameTime = 0
    this.targetFps = 20 
    this.fpsInterval = 1000 / this.targetFps
    this.frameSkipCounter = 0
    this.maxFrameSkip = 3 

    this.baseHeartCount = heartCount 
    this.minHearts = minHearts
    this.maxClickHearts = 15
    this.maxTotalHearts = 30

    this.cssWidth = 0
    this.cssHeight = 0
    this.isVisible = true
    this.animationId = null
    this.isInitialized = false

    this.batchSize = 5
    this.updateBatch = 0

    this.init()
  }

  init() {
    if (this.isInitialized) return
    this.isInitialized = true

    this.resizeCanvas()

    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver(() => this.resizeCanvas())
      this.resizeObserver.observe(this.canvas)
    } else {
      this.resizeHandler = this.resizeCanvas.bind(this)
      window.addEventListener("resize", this.resizeHandler)
    }

    this.visibilityHandler = () => {
      this.isVisible = !document.hidden
      if (this.isVisible && this.isRunning) {
        this.lastFrameTime = performance.now()
        this.animate(this.lastFrameTime)
      }
    }
    document.addEventListener("visibilitychange", this.visibilityHandler)

    this.lastClickTime = 0
    this.clickThrottle = 100 
    this.clickHandler = (e) => {
      const now = performance.now()
      if (now - this.lastClickTime < this.clickThrottle) return
      this.lastClickTime = now
      this.handleClick(e)
    }
    this.canvas.addEventListener("click", this.clickHandler)

    this.loadHeartImage()
  }

  loadHeartImage() {
    this.heartImage.onload = () => {
      if (this.loader) this.loader.style.display = "none"
      this.generateInitialHearts()
      this.start()
    }

    this.heartImage.onerror = () => {
      this.heartImageSrc = "/assets/red-heart.svg"
      this.heartImage.src = this.heartImageSrc
      this.heartImage.onload = () => {
        if (this.loader) this.loader.style.display = "none"
        this.generateInitialHearts()
        this.start()
      }
    }

    this.heartImage.src = this.heartImageSrc
  }

  generateInitialHearts() {
    const target = this.getEffectiveBaseCount()
    this.hearts = []
    for (let i = 0; i < target; i++) {
      this.hearts.push(this.createHeart())
    }
  }

  getEffectiveBaseCount() {
    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1))
    const screenArea = (this.cssWidth || window.innerWidth) * (this.cssHeight || window.innerHeight)
    const scaleFactor = Math.min(1, screenArea / 1000000) 
    return Math.max(this.minHearts, Math.round((this.baseHeartCount * scaleFactor) / dpr))
  }

  updateHeartImage(theme) {
    if (this.isLoadingTheme) return
    this.isLoadingTheme = true

    const themeHeartPath = `/assets/${theme}-heart.svg`
    const newHeartImage = new Image()

    newHeartImage.onload = () => {
      this.heartImageSrc = themeHeartPath
      this.heartImage = newHeartImage
      this.hearts.forEach((h) => (h.img = this.heartImage))
      this.isLoadingTheme = false
    }

    newHeartImage.onerror = () => {
      const fallbackImage = new Image()
      fallbackImage.onload = () => {
        this.heartImageSrc = "/assets/red-heart.svg"
        this.heartImage = fallbackImage
        this.hearts.forEach((h) => (h.img = this.heartImage))
        this.isLoadingTheme = false
      }
      fallbackImage.src = "/assets/red-heart.svg"
    }

    newHeartImage.src = themeHeartPath
  }

  resizeCanvas() {
    if (!this.canvas) return

    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1))
    const oldCssWidth = this.cssWidth || this.canvas.clientWidth || window.innerWidth
    const oldCssHeight = this.cssHeight || this.canvas.clientHeight || window.innerHeight

    this.cssWidth = this.canvas.clientWidth || window.innerWidth
    this.cssHeight = this.canvas.clientHeight || window.innerHeight

    this.canvas.width = Math.floor(this.cssWidth * dpr)
    this.canvas.height = Math.floor(this.cssHeight * dpr)
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0)

    if (this.hearts.length && oldCssWidth && oldCssHeight) {
      const scaleX = this.cssWidth / oldCssWidth
      const scaleY = this.cssHeight / oldCssHeight
      this.hearts.forEach((h) => {
        h.x *= scaleX
        h.y *= scaleY
      })
    }

    this.adjustHeartCount()
  }

  adjustHeartCount() {
    const target = this.getEffectiveBaseCount()
    const baseHearts = this.hearts.filter((h) => !h.isClickHeart)

    if (baseHearts.length < target) {
      const toAdd = target - baseHearts.length
      for (let i = 0; i < toAdd; i++) {
        this.hearts.push(this.createHeart())
      }
    } else if (baseHearts.length > target) {
      let toRemove = baseHearts.length - target
      for (let i = this.hearts.length - 1; i >= 0 && toRemove > 0; i--) {
        if (!this.hearts[i].isClickHeart) {
          this.hearts.splice(i, 1)
          toRemove--
        }
      }
    }

    if (this.hearts.length > this.maxTotalHearts) {
      this.hearts = this.hearts.slice(0, this.maxTotalHearts)
    }
  }

  createHeart() {
    return {
      img: this.heartImage,
      x: Math.random() * (this.cssWidth || window.innerWidth),
      y: Math.random() * (this.cssHeight || window.innerHeight),
      dx: Math.random() * 0.2 - 0.1, 
      dy: Math.random() * 0.2 + 0.1, 
      size: Math.random() * 15 + 15,
      rotation: Math.random() * 0.2 - 0.1, 
      rotationSpeed: Math.random() * 0.005 - 0.0025, 
      opacity: 1.0, 
      isClickHeart: false,
    }
  }

  start() {
    if (!this.isRunning) {
      this.isRunning = true
      this.lastFrameTime = performance.now()
      this.animationId = requestAnimationFrame(this.animate.bind(this))
    }
  }

  stop() {
    this.isRunning = false
    if (this.animationId) {
      cancelAnimationFrame(this.animationId)
      this.animationId = null
    }
  }

  animate(timestamp) {
    if (!this.isRunning || !this.isVisible) {
      if (this.isRunning) {
        this.animationId = requestAnimationFrame(this.animate.bind(this))
      }
      return
    }

    const elapsed = timestamp - this.lastFrameTime

    if (elapsed < this.fpsInterval) {
      this.animationId = requestAnimationFrame(this.animate.bind(this))
      return
    }

    if (elapsed > this.fpsInterval * 2.5) {
      this.frameSkipCounter++
      if (this.frameSkipCounter < this.maxFrameSkip) {
        this.animationId = requestAnimationFrame(this.animate.bind(this))
        return
      }
      this.frameSkipCounter = 0
    }

    this.lastFrameTime = timestamp - (elapsed % this.fpsInterval)
    this.ctx.clearRect(0, 0, this.cssWidth, this.cssHeight)

    const heartsToProcess = Math.min(this.hearts.length, this.batchSize + this.updateBatch)

    for (let i = this.hearts.length - 1; i >= 0; i--) {
      const h = this.hearts[i]

      if (i > heartsToProcess && !h.isClickHeart) {
        this.drawHeart(h)
        continue
      }

      this.updateHeart(h, i)
      this.drawHeart(h)
    }

    this.updateBatch = (this.updateBatch + this.batchSize) % this.hearts.length
    this.animationId = requestAnimationFrame(this.animate.bind(this))
  }

  updateHeart(h, index) {
    h.x += h.dx
    h.y += h.dy
    h.rotation += h.rotationSpeed

    if (h.isClickHeart) {
      h.life -= 1
      h.opacity = Math.max(0, h.life / h.maxLife)
      h.dy += 0.015 
      if (h.life <= 0) {
        this.hearts.splice(index, 1)
        return
      }
    } else {
      const limitX = this.cssWidth + h.size
      const limitY = this.cssHeight + h.size
      if (h.y > limitY) {
        h.y = -h.size
        h.x = Math.random() * this.cssWidth
        h.dy = Math.random() * 0.2 + 0.1
      }
      if (h.x < -h.size) h.x = this.cssWidth + h.size
      if (h.x > this.cssWidth + h.size) h.x = -h.size
    }
  }

  drawHeart(h) {
    this.ctx.globalAlpha = h.opacity

    if (Math.abs(h.rotation) > 0.005) {
      this.ctx.save()
      this.ctx.translate(h.x, h.y)
      this.ctx.rotate(h.rotation)
      this.ctx.drawImage(h.img, -h.size / 2, -h.size / 2, h.size, h.size)
      this.ctx.restore()
    } else {
      this.ctx.drawImage(h.img, h.x - h.size / 2, h.y - h.size / 2, h.size, h.size)
    }
  }

  handleClick(e) {
    const clickHearts = this.hearts.filter((h) => h.isClickHeart)
    if (clickHearts.length >= this.maxClickHearts || this.hearts.length >= this.maxTotalHearts) return

    const rect = this.canvas.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top
    const n = Math.floor(Math.random() * 2) + 1 

    for (let i = 0; i < n && this.hearts.length < this.maxTotalHearts; i++) {
      const maxLife = 30 + Math.floor(Math.random() * 15) 
      this.hearts.push({
        img: this.heartImage,
        x: x + (Math.random() * 20 - 10), 
        y: y + (Math.random() * 20 - 10),
        dx: Math.random() * 1 - 0.5, 
        dy: Math.random() * -1 - 0.3,
        size: Math.random() * 20 + 20,
        rotation: Math.random() * 0.02 - 0.01,
        rotationSpeed: Math.random() * 0.4 - 0.2,
        opacity: 1,
        isClickHeart: true,
        life: maxLife,
        maxLife,
      })
    }
  }

  destroy() {
    this.stop()

    if (this.resizeObserver) {
      this.resizeObserver.disconnect()
    } else if (this.resizeHandler) {
      window.removeEventListener("resize", this.resizeHandler)
    }

    if (this.visibilityHandler) {
      document.removeEventListener("visibilitychange", this.visibilityHandler)
    }

    if (this.clickHandler) {
      this.canvas.removeEventListener("click", this.clickHandler)
    }

    this.hearts = []
    OptimizedHeartAnimation.instance = null
  }
}

if (typeof window !== "undefined") {
  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.heartAnimation = new OptimizedHeartAnimation()
    })
  } else {
    window.heartAnimation = new OptimizedHeartAnimation()
  }
}




class LoadingManager {
  constructor(appState) {
    this.appState = appState
    this.loadingBar = document.getElementById("loadingBar")
    this.loadingScreen = document.getElementById("loadingScreen")
    this.loadingText = document.querySelector(".loading-text")
  }

  init() {
    let progress = 0
    const startTime = performance.now()
    const deviceTier = this.appState.performanceMonitor.deviceTier

    const isSlowDevice = () => this.appState.performanceMonitor.isLowEndDevice
    const incrementAmount = isSlowDevice() ? 2 : deviceTier === "medium" ? 4 : 8
    const incrementInterval = isSlowDevice() ? 150 : deviceTier === "medium" ? 100 : 60

    if (this.loadingText) {
      this.loadingText.textContent = `Detecting device performance (${deviceTier})...`
    }

    const loadingInterval = setInterval(() => {
      if (progress < 100) {
        progress += incrementAmount

        if (progress > 100) progress = 100

        requestAnimationFrame(() => {
          if (this.loadingBar) this.loadingBar.style.width = `${progress}%`
        })

        if (this.loadingText) {
          if (progress < 30) {
            this.loadingText.textContent = `Loading click data (${deviceTier} mode)...`
          } else if (progress < 60) {
            this.loadingText.textContent = `Loading exploits status (${deviceTier} mode)...`
          } else if (progress < 90) {
            this.loadingText.textContent = `Almost ready (${deviceTier} mode)...`
          } else {
            const totalTime = performance.now() - startTime
            this.loadingText.textContent = `Loaded in ${totalTime.toFixed(0)}ms (${deviceTier} mode)`
          }
        }
      } else {
        clearInterval(loadingInterval)

        setTimeout(
          () => {
            if (this.loadingScreen) {
              this.loadingScreen.style.transition = "opacity 0.8s ease, visibility 0.8s ease"
              this.loadingScreen.style.opacity = "0"
              this.loadingScreen.style.visibility = "hidden"

              setTimeout(() => {
                this.loadingScreen.remove()
              }, 800)
            }
          },
          isSlowDevice() ? 1000 : deviceTier === "medium" ? 600 : 300,
        )
      }
    }, incrementInterval)

    return this
  }
}

class FloatingWarningSystem {
  constructor() {
    this.warning = document.getElementById("floatingWarning")
    if (!this.warning) return

    this.isVisible = false
    this.lastScrollY = window.pageYOffset
    this.scrollThreshold = 15

    this.hideTimeout = null
    this.userClosed = false

    this.init()
  }

  init() {
    if (sessionStorage.getItem("warningClosed") === "true") {
      this.userClosed = true
      this.warning.style.display = "none"
      return
    }
    setTimeout(() => this.showWarning(), 1500)
    this.setupScrollListener()
  }

  setupScrollListener() {}
  handleScroll() {
    if (this.userClosed) return
    const currentScrollY = window.pageYOffset
    const isAtTop = currentScrollY < 50
    const isScrollingUp = currentScrollY < this.lastScrollY
    const isScrollingDown = currentScrollY > this.lastScrollY

    if (isAtTop) {
      if (this.isVisible) this.hideWarning()
    } else if (isScrollingUp) {
      if (!this.isVisible) this.showWarning()
    } else if (isScrollingDown && Math.abs(currentScrollY - this.lastScrollY) > this.scrollThreshold) {
      if (this.isVisible) this.hideWarning()
    }
    this.lastScrollY = currentScrollY <= 0 ? 0 : currentScrollY
  }

  showWarning() {
    if (this.isVisible || this.userClosed) return
    this.warning.classList.add("is-visible")
    this.isVisible = true
    clearTimeout(this.hideTimeout)
    this.hideTimeout = setTimeout(() => this.hideWarning(), 8000)
  }

  hideWarning() {
    if (!this.isVisible) return
    this.warning.classList.remove("is-visible")
    this.isVisible = false
    clearTimeout(this.hideTimeout)
  }

  close() {
    this.hideWarning()
    this.userClosed = true
    sessionStorage.setItem("warningClosed", "true")
  }
}

class TopWarningBar {
  constructor() {
    this.warningBar = document.getElementById("topWarningBar")
    if (!this.warningBar) return

    this.userClosed = false
    this.warningBarHeight = 0

    this.init()
  }

  init() {
    if (sessionStorage.getItem("topWarningClosed") === "true") {
      this.userClosed = true
      this.warningBar.style.display = "none"
      document.body.classList.remove("has-top-warning")
      return
    }

    this.warningBarHeight = this.warningBar.offsetHeight
    document.documentElement.style.setProperty("--warning-bar-height", `${this.warningBarHeight}px`)

    document.body.classList.add("has-top-warning")
  }

  setupScrollListener() {
    let ticking = false
    window.addEventListener("scroll", () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          this.handleScroll()
          ticking = false
        })
        ticking = true
      }
    })
  }

  setupTransitionListener() {
    this.warningBar.addEventListener("transitionend", (e) => {
      if (e.propertyName === "transform" && !this.isVisible) {
        document.body.classList.remove("has-top-warning")
      }
    })
  }

  handleScroll() {
    if (this.userClosed) return
    const isAtTop = window.pageYOffset <= this.topThreshold
    if (isAtTop && !this.isVisible) {
      this.showWarning()
    }
  }

  showWarning() {
    if (this.isVisible || this.userClosed) return
    document.body.classList.add("has-top-warning")
    this.warningBar.offsetHeight
    this.warningBar.classList.add("is-visible")
    this.isVisible = true
  }

  hideWarning() {
    if (!this.isVisible) return
    this.warningBar.classList.remove("is-visible")
    this.isVisible = false
  }

  close() {
    this.hideWarning()
    this.userClosed = true
    sessionStorage.setItem("topWarningClosed", "true")
  }
}

let floatingWarningInstance
let topWarningBarInstance

document.addEventListener("DOMContentLoaded", () => {
  floatingWarningInstance = new FloatingWarningSystem()
  topWarningBarInstance = new TopWarningBar()
})

document.addEventListener("DOMContentLoaded", async () => {
  const appState = new AppState()

  await appState.init()

  const uiManager = new UIManager(appState).init()
  const themeManager = new ThemeManager().init()
  const loadingManager = new LoadingManager(appState).init()
  window.heartAnimation = new OptimizedHeartAnimation()

  clickTracker = appState.clickTracker

  setTimeout(() => {
    uiManager.setupCardButtons()
  }, 500)

  console.log(`Device performance tier: ${appState.performanceMonitor.deviceTier}`)
  console.log(`Low-end device: ${appState.performanceMonitor.isLowEndDevice ? "Yes" : "No"}`)
})

window.addEventListener("load", () => {
  setTimeout(() => {
    if (clickTracker) {
      clickTracker.retryFailedClicks()
    }
  }, 5000)
})

window.addEventListener("load", () => {
  if ("performance" in window) {
    const perfData = performance.getEntriesByType("navigation")[0]
    console.log("Page load performance:", {
      domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
      loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
      totalTime: perfData.loadEventEnd - perfData.fetchStart,
    })
  }
})

class ReportManager {
  static init() {
    const reportBtn = document.getElementById("reportBtn")
    const mobReportBtn = document.getElementById("mobReportBtn")
    const reportModal = document.getElementById("reportModal")
    const reportModalClose = document.getElementById("reportModalClose")
    const reportCancelBtn = document.getElementById("reportCancelBtn")
    const reportForm = document.getElementById("reportForm")
    const reportModalOverlay = document.querySelector(".report-modal-overlay")

    if (reportBtn) {
      reportBtn.addEventListener("click", ReportManager.openModal)
    }

    if (mobReportBtn) {
      mobReportBtn.addEventListener("click", ReportManager.openModal)
    }

    if (reportModalClose) {
      reportModalClose.addEventListener("click", ReportManager.closeModal)
    }

    if (reportCancelBtn) {
      reportCancelBtn.addEventListener("click", ReportManager.closeModal)
    }

    if (reportModalOverlay) {
      reportModalOverlay.addEventListener("click", ReportManager.closeModal)
    }

    if (reportForm) {
      reportForm.addEventListener("submit", ReportManager.handleSubmit)
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && reportModal && reportModal.classList.contains("active")) {
        ReportManager.closeModal()
      }
    })
  }

  static openModal() {
    const modal = document.getElementById("reportModal")
    if (modal) {
      modal.style.display = "flex"
      setTimeout(() => {
        modal.classList.add("active")
      }, 10)
      document.body.style.overflow = "hidden"
    }
  }

  static closeModal() {
    const modal = document.getElementById("reportModal")
    if (modal) {
      modal.classList.remove("active")
      setTimeout(() => {
        modal.style.display = "none"
        document.body.style.overflow = ""
        ReportManager.resetForm()
      }, 300)
    }
  }

  static resetForm() {
    const form = document.getElementById("reportForm")
    if (form) {
      form.reset()
    }
  }

  static async handleSubmit(e) {
    e.preventDefault()

    const lastReport = localStorage.getItem("lastReportTime")
    const now = Date.now()
    const fifteenMinutes = 15 * 60 * 1000

    if (lastReport && now - Number.parseInt(lastReport) < fifteenMinutes) {
      const remainingTime = Math.ceil((fifteenMinutes - (now - Number.parseInt(lastReport))) / 60000)
      return
    }

    const sendBtn = document.getElementById("reportSendBtn")
    const title = document.getElementById("reportTitle").value.trim()
    const description = document.getElementById("reportDescription").value.trim()

    if (!title || !description) {
      
      return
    }

    sendBtn.disabled = true
    sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...'

    try {
      const response = await fetch("https://api.voxlis.net/report-voxlis.php", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title: title,
          description: description,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer || "Direct",
        }),
      })

      const result = await response.json()

      if (result.success) {
        localStorage.setItem("lastReportTime", now.toString())
        
        ReportManager.closeModal()
      } else {
        throw new Error(result.message || "Failed to submit report")
      }
    } catch (error) {
      console.error("Report submission error:", error)
      
    } finally {
      sendBtn.disabled = false
      sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send Report'
    }
  }
}

document.addEventListener("DOMContentLoaded", () => {
  ReportManager.init()
})




class MobileMenuManager {
  constructor() {
    this.menu = document.getElementById("mobMenu")
    this.menuToggle = document.getElementById("mobMenuTgl")
    this.closeButton = null
    this.isAnimating = false

    this.init()
  }

  init() {
    
    this.addCloseButton()

    
    this.setupEventListeners()
    
    
    if (this.menuToggle) {
      this.menuToggle.innerHTML = '<i class="fas fa-bars"></i>'
    }
  }

  addCloseButton() {
    if (!this.menu) return

    const menuContainer = this.menu.querySelector(".mob-menu-cntr")
    if (!menuContainer) return

    
    let closeButton = document.getElementById("mobMenuClose")
    if (!closeButton) {
      
      closeButton = document.createElement("button")
      closeButton.id = "mobMenuClose"
      closeButton.className = "mob-menu-close"
      closeButton.innerHTML = '<i class="fas fa-times"></i>'

      
      menuContainer.insertBefore(closeButton, menuContainer.firstChild)
    }

    this.closeButton = closeButton
  }

  setupEventListeners() {
    
    if (this.closeButton) {
      this.closeButton.addEventListener("click", (e) => {
        e.preventDefault()
        e.stopPropagation()
        this.closeMenu()
      })
    }

    
    if (this.menu) {
      this.menu.addEventListener("click", (e) => {
        if (e.target === this.menu) {
          this.closeMenu()
        }
      })
    }

    
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !this.menu.classList.contains("hidden")) {
        this.closeMenu()
      }
    })
  }

  closeMenu() {
    if (this.isAnimating || !this.menu || this.menu.classList.contains("hidden")) {
      return
    }

    this.isAnimating = true

    

    this.menu.style.transform = "translateY(-100%)"
    this.menu.style.opacity = "0"

    setTimeout(() => {
      this.menu.classList.add("hidden")
      document.body.classList.remove("menu-open")
      document.body.style.overflow = ""

      
      this.menu.style.transform = ""
      this.menu.style.opacity = ""

      this.isAnimating = false
    }, 450)
  }

  openMenu() {
    if (this.isAnimating || !this.menu || !this.menu.classList.contains("hidden")) {
      return
    }

    this.isAnimating = true

    

    this.menu.classList.remove("hidden")
    document.body.classList.add("menu-open")
    document.body.style.overflow = "hidden"

    setTimeout(() => {
      this.isAnimating = false
    }, 450)
  }
}


document.addEventListener("DOMContentLoaded", () => {
  window.mobileMenuManager = new MobileMenuManager()

  const menuToggle = document.getElementById("mobMenuTgl")
  const menu = document.getElementById("mobMenu")

  if (menuToggle && menu) {
    
    const newMenuToggle = menuToggle.cloneNode(true)
    menuToggle.parentNode.replaceChild(newMenuToggle, menuToggle)

    
    newMenuToggle.addEventListener("click", () => {
      if (menu.classList.contains("hidden")) {
        window.mobileMenuManager.openMenu()
      } else {
        window.mobileMenuManager.closeMenu()
      }
    })
  }
})








